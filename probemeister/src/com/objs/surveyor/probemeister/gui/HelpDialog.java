/* 
 * <copyright> 
 *   
 *  Copyright 1999-2004 Object Services and Consulting, Inc. 
 *  under sponsorship of the Defense Advanced Research Projects 
 *  Agency (DARPA). 
 *  
 *  You can redistribute this software and/or modify it under the 
 *  terms of the Cougaar Open Source License as published on the 
 *  Cougaar Open Source Website (www.cougaar.org). 
 *  
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 *   
 * </copyright> 
 */ 

/*
 */

package com.objs.surveyor.probemeister.gui;
import com.objs.surveyor.probemeister.*;


import java.awt.*;
import javax.swing.JTextPane;
import javax.swing.JScrollPane;
import javax.swing.text.StyleConstants;
import javax.swing.text.SimpleAttributeSet;
import javax.swing.text.AttributeSet;
import javax.swing.text.BadLocationException;

public class HelpDialog extends javax.swing.JDialog {
    
    static SimpleAttributeSet header = new SimpleAttributeSet();
    static SimpleAttributeSet item = new SimpleAttributeSet();
    static SimpleAttributeSet italic = new SimpleAttributeSet();
    static SimpleAttributeSet body   = new SimpleAttributeSet();
    static SimpleAttributeSet basic   = new SimpleAttributeSet();
    static SimpleAttributeSet note   = new SimpleAttributeSet();
    
    
    public HelpDialog(Frame _parent, boolean _modal)
    {
	super(_parent, _modal);
	
        defineStyles();
	
	
	// This code is automatically generated by Visual Cafe when you add
	// components to the visual environment. It instantiates and initializes
	// the components. To modify the code, only use code syntax that matches
	// what Visual Cafe can generate, or Visual Cafe may be unable to back
	// parse your Java file into its visual environment.
        
	//{{INIT_CONTROLS
	GridBagLayout grid = new GridBagLayout();
	GridBagConstraints cons = new GridBagConstraints();
	
	getContentPane().setLayout(grid);
	getContentPane().setBackground(java.awt.Color.lightGray);
	getContentPane().setBounds(100, 100, 467, 342);
	setSize(467,342);
	setVisible(false);
	lTitle.setAlignment(java.awt.Label.CENTER);
	
	cons.weightx=1;
	cons.weighty=0;
	cons.gridx=0;
	cons.gridy=0;
	cons.insets = new Insets(15,0,15,0);
	getContentPane().add(lTitle,cons);
	
	lTitle.setForeground(java.awt.Color.blue);
	lTitle.setFont(new Font("Dialog", Font.BOLD, 14));
//	lTitle.setBounds(28,20,411,26);
	
	cons.gridx=0;
	cons.gridy=1;
	cons.weightx=1;
	cons.weighty=1;
	cons.fill = GridBagConstraints.BOTH;
	cons.gridheight = 2;
	cons.insets = new Insets(0,7,0,7);
	getContentPane().add(JScrollPane1, cons);
	JScrollPane1.setBounds(26,51,414,228);
	JScrollPane1.getViewport().add(tData);
//	tData.setBounds(0,0,411,225);
	tData.setEditable(false);

	okButton.setLabel("OK");
		
	cons.weighty=0;
	cons.weightx=0;
	cons.gridx=0;
	cons.gridy=3;
	cons.ipadx=16;
	cons.fill = GridBagConstraints.NONE;
	cons.insets = new Insets(15,0,15,0);
	getContentPane().add(okButton,cons);

//	okButton.setBounds(195,294,66,27);
		
	lTitle.setText("Help");
	setTitle("ProbeMeister Help");
	//}}
        
	//{{REGISTER_LISTENERS
	SymWindow aSymWindow = new SymWindow();
	this.addWindowListener(aSymWindow);
	SymAction lSymAction = new SymAction();
	okButton.addActionListener(lSymAction);
	//}}
	
    }
    
    private void defineStyles() {
	//define styles
	StyleConstants.setFontSize(header, 14);
	StyleConstants.setBold(header, true);
	StyleConstants.setFontFamily(header, "Helvetica");
	
	StyleConstants.setFontSize(item, 12);
	StyleConstants.setBold(item, true);
	StyleConstants.setFontFamily(item, "Helvetica");
        StyleConstants.setLeftIndent(item, 3);
	StyleConstants.setUnderline(item, true);

	StyleConstants.setFontFamily(body, "Helvetica");	    
        StyleConstants.setLeftIndent(body, 6);

	StyleConstants.setFontFamily(note, "Helvetica");	    
        StyleConstants.setLeftIndent(note, 10);
	StyleConstants.setFontSize(note, 10);
	StyleConstants.setBold(note, true);
	
	StyleConstants.setFontFamily(basic, "monospaced");	    
        StyleConstants.setLeftIndent(basic, 6);
	
	StyleConstants.setItalic(italic, true);	    
        StyleConstants.setLeftIndent(italic, 6);
    }
    
    private void noHelpText() {
        insertText("No Help File Loaded\n\n", header);
    }
    
    private void connectingHelpText() {
	setTitle("ProbeMeister Help");
        lTitle.setText("Connecting to another application");
        
        insertText("Introduction:\n\n", header);
        insertText("To probe another application you must start it using "+
		   "a special JDK 1.4 command line that looks like: \n"+
		   "   java -Xdebug -Xnoagent -Xrunjdwp:<options> <main classname>"+
		   "\n", body);        
        insertText("\nThe <options> control whether your application initiates contact with "+
		   "ProbeMeister or if ProbeMeister should initiate contact, and describes the form " +
		   "of the communication. These options are described "+
		   "below.\n", body);
	
        insertText("\nTransport\n", item);
        insertText("The transport option simply states whether the communication is local "+
		   "through shared memory (dt_shmem), or remote using a socket (dt_socket). Sockets can " +
		   "be used locally too. "+
		   "In general, use a socket.\n\nThe form is: \n\n     transport=dt_socket\n\n", body);
	
        insertText("Server\n", item);
        insertText("The server option identifies which application initiates contact (acts as "+
		   "the client), and which application accepts contact requests (acts as the server). "+
		   "\n\nIt is probably easier if the application acts as a client & contacts ProbeMeister "+
		   "when it is running. ProbeMeister will then make the application available for probing "+
		   "via the \"Waiting VMs\" list in the main window. Otherwise, you can also contact the "+
		   "application (it acts as the server) from within ProbeMeister via the \"Attach To VM\" "+
		   "menu option.", body);
        insertText("\n\nSo, the options are: \n\n     server=n <application acts as a client>, or "+
		   "\n     server=y <application acts as a server>.", body);
	
        insertText("\n\nAddress\n", item);
        insertText("The address option specifies the address of the SERVER. As such, if the "+
		   "application is acting as the server, you must assign a port number if using "+
		   "socket communication, or a string id if using shared memory. \n\nIf the application "+
		   "will be the client, then the address should be the address defined by ProbeMeister. "+
		   "Again, if shared memory is being used the address will be a string id, otherwise when "+
		   "using sockets, the address should be <portNumber> (for local connections) and <host:port> "+
		   "for remote connections. Inspect the DOS Console to determine the address ProbeMeister is " +
		   "using (ProbeMeister acts as both server and client).", body);
        insertText("\n\nSo, the options are: \n\n     address=foo <shared memory access>, or "+
		   "\n     address=1234 <local, socket access>." +
		   "\n     address=fooHost.objs.com:1234 <remote socket access>.", body);
	
        insertText("\n\nSuspend\n", item);
        insertText("The suspend option specifies whether the application starts up and waits "+
		   "for communication with ProbeMeister to be established and further waits for the user "+
		   "to resume its execution, or if it should execute normally -- in which case "+
		   "it will run whether or not ProbeMeister is running.\n\n If you want to modify "+
		   "the execution of the program from its start, or want to load up a probe configuration "+
		   "then the application should start up suspended.", body);
        insertText("\n\nSo, the options are: \n\n     suspend=y <wait for ProbeMeister/user>, or "+
		   "\n     suspend=n <begin execution without waiting>.", body);
	
	
        insertText("\n\nExamples:\n", header);
        insertText("To make a (local or remote) socket connection on port 9876 to ProbeMeister starting "+
		   "the SimpleExample application as a suspended server, " +
		   "use the following command-line: \n\n", body);
        insertText("   java -Xdebug -Xnoagent -Xrunjdwp:transport=dt_socket,server=y,address=9876,suspend=y SimpleExample"+
		   "", italic);
    }
       
    private void configHelpText() {
	setTitle("ProbeMeister Help");
	lTitle.setText("Using Configuration Files");
	
        insertText("Configuration Files\n\n", header);
        insertText("Configuration files are used to record modifications "+
		   "that are made to an application via ProbeMeister. " +
		   "As you insert probes, and add/modify classes in the " +
		   "monitored application, an instrumentation recorder " +
		   "keeps track (sequentially) of everything. " +
		   "Each application instrumented has its own history. ", body);        
	
        insertText("\n\nSave Configuration...\n", item);
        insertText("At any time you may save the instrumentation changes "+
		   "you've made to a given application. If you make more " +
		   "modifications, you may save again -- the resulting file " +
		   "will contain ALL past instrumentation actions performed. ", body);
	
        insertText("\n\nApply Configuration...\n", item);
        insertText("The real purpose of configuration files are to "+
		   "eliminate the need to continually re-instrument applications "+
		   "by remembering what you did the last time. At any point you "+
		   "can load and apply a configuration file to the current application. "+
		   "ProbeMeister will sequentially apply all instrumentations defined " +
		   "in the file. Configuration files will not be applied unless all "+
		   "classes mentioned in the file exist in the target application. ", body);
	
        insertText("\n\nDe-Apply Configuration...\n", item);
        insertText("It is also possible (at least partially) to reverse the effects "+
		   "of applying a configuration. Essentially, this removes all probes "+
		   "that were previously inserted, as described in a configuration file. "+
		   "However, it cannot undefine classes, nor can it unredefine a class "+
		   "[unless the original class is available (future capability)]", body);
	
        insertText("\n\nView Active Configuration\n", item);
        insertText("Inspect the current state of the active configuration for a given Target VM. ", body);        
	
        insertText("\n\nView Configuration File...\n", item);
        insertText("This provides a viewer to inspect a configuration file "+
		   "(this is useful to do prior to applying it to or extracting it from an application). ", body);
        
	
    }
	
    private void redefineHelpText() {
	setTitle("ProbeMeister Help");
	lTitle.setText("Defining and Redefining Classes");
	
        insertText("Defining Classes\n\n", header);
        insertText("This capability enables new, non-resident, classes to be loaded into "+
		   "the remote running target JVM. This is required when probes reference classes "+
		   "that do not exist in the target VM.  ", body);
	
        insertText("\n\nThe only caveat (thanks to JDK14) is "+
		   "that updates can only occur when a breakpoint has been reached in the "+
		   "target VM. ProbeMeister has overcome this caveat (in MOST cases) through a complex feat of engineering, "+
		   "enabling ProbeMeister to controlling breakpointing in the Target VM.", italic);        
	
        insertText("\n\nBecause of breakpoint requirement, class definition requests are "+
		   "queued prior to seeing a breakpoint and applied all at once when a "+
		   "breakpoint event occurs (in some cases ProbeMeister cannot effect breakpoints, and "+
		   "as such, will not be able to perform this operation).", body);
	
        insertText("\n\nProgrammatic Note: To accomplish class definintion, one registers as a "+
		   "TargetVMListener and waits for a breakpoint event. Then class definition "+
		   "can take place via a direct call to exportClassToTargetVM(), or by invoking "+
		   "reapply() on a InstrumentationRecord_NewClass instance.", note);
	
        insertText("\n\nRedefining Classes\n\n", header);
        insertText("This capability is needed when modifications have already been applied to a " +
		   "class. This may include classes involving statically inserted probes, as well "+
		   "as classes that have been otherwise modified. In this latter case, this feature "+
		   "could be used to test modifications by swapping in and out different "+
		   "versions of a class.", body);
        insertText("\n\nThe TargetVM may impose restrictions on the types of modifications that are allowed. "+
		   "The default capability (supported by Sun's VM) does not allow for additions (e.g. new fields/methods), "+
		   "only modifications to the existing class definition. An exception will be thrown, and error displayed "+
		   "if classes with unsupported modifications are submitted.", body);
	
        insertText("\n\nProgrammatic Note: To redefine a class one calls RuntimeClassMgr.redefineClass().", note);
    }
    
    private void loggerHelpText() {
	setTitle("ProbeMeister Help");
	lTitle.setText("Using ProbeMeister As A Logger Event Collector");
	
        insertText("Logging\n\n", header);
        insertText("You can use PM to collect and display events emitted from Logger probes " +
                   "that you have deployed into remote applications. To do so you must first "+
                   "configure and deploy the Logger Initialization Probe to a JVM (one per "+
                   "JVM, though you could deploy more than one to collect to different loggers). "+
                   "When configuring this probe, select the \"Use PM\" checkbox, otherwise you "+
                   "need to run your own event collector (com.objs.probemeister.PMLogServer is a " +
                   "working example of one). ", body);
	
        insertText("\n\nThe probe should be deployed into a location that will be executed once so " +
                   "the code is not run more than once. This is a matter of efficiency as it will still "+
                   "work otherwise (executing multiple time), it's just not recommended.", note);
	
        insertText("\n\nMultiple JVMs\n\n", header);
        insertText("\n\nIf you have multiple JVMs, if you use the same port number when configuring the " +
                   "Logger Initialization probe, output from all JVMs will be collected to the same "+
                   "window. Otherwise, the output from each JVM will go to its own window. You can also "+
                   "mix & match -- some JVMs share a window while others do not.", body);
	
        insertText("\n\nDeploying Logger Probes\n\n", header);
        insertText("\n\nOnce the Logger Initialization probe has been deployed, you may deploy Logger probes. " +
                   "Make sure that you use the same Logger name you assigned during initialization, otherwise " +
                   "you will not see any Logger events. ", body);
	
        insertText("\n\nThe XMLFormatter used by default has a bug in it such that it will not emit any argument " +
                   "data passed to it. I have filed a bug report... If you want to see the arguments that you may "+
                   "emit using the Logger probes, you will need to use a patched version of the XMLFormatter & also " +
                   "make sure that class file is in the classpath of each JVM you will be probing. ", note);

        insertText("\n\nCustomized Formatters\n\n", header);
        insertText("\n\nThe formatter that outputs logger events can be customized/extended to emit data in any " +
                   "format you desire. Once extended, simply include the full name of this class when deploying " +
                   "the Logger Initialization probe (in the Formatter field). Then, all log events will be formatted "+
                   "by this formatter before being emitted to the log monitor you have chosen. ", body);
    }

    protected void insertText(String text, AttributeSet set) {
        try {
            tData.getDocument().insertString(
					     tData.getDocument().getLength(), text, set); 
        } 
        catch (BadLocationException e) {
	    e.printStackTrace();
        }
    }
    
    // Needed for inserting icons/text in the right places
    protected void setEndSelection() {
        tData.setSelectionStart(tData.getDocument().getLength());
        tData.setSelectionEnd(tData.getDocument().getLength());    
    }
    
    public HelpDialog(Frame _parent, String _title, boolean _modal)
    {
	this(_parent, _modal);
	setTitle(_title);
    }
    
    public void addNotify()
    {
	// Record the size of the window prior to calling parents addNotify.
	Dimension d = getSize();
	
	super.addNotify();
	
	// Only do this once.
	if (fComponentsAdjusted)
	    return;
	
	// Adjust components according to the insets
	Insets insets = getInsets();
	setSize(insets.left + insets.right + d.width, insets.top + insets.bottom + d.height);
	Component components[] = getComponents();
	for (int i = 0; i < components.length; i++)
	    {
		Point p = components[i].getLocation();
		p.translate(insets.left, insets.top);
		components[i].setLocation(p);
	    }
	
	// Used for addNotify check.
	fComponentsAdjusted = true;
    }
    
    public void setVisible(String _configDataStr)
    {
	setTitle("ProbeMeister");
	lTitle.setText("Basic Configuration Viewer");
	
	try {
    	    tData.getDocument().remove(0, tData.getDocument().getLength());
        } catch (BadLocationException bde) {
            
        }
        insertText(_configDataStr, basic);
        tData.setCaretPosition(0);
	
    	Rectangle bounds = getParent().getBounds();
    	Rectangle abounds = getBounds();
	
    	setLocation(bounds.x + (bounds.width - abounds.width)/ 2,
		    bounds.y + (bounds.height - abounds.height)/2);
	
	super.setVisible(true);
    }

    public void setVisible(boolean b, String textToShow)
    {
	if (b)
	    {
	        //first remove all data
	        try {
		    tData.getDocument().remove(0, tData.getDocument().getLength());
		} catch (BadLocationException bde) {
		    
		}
	        if (textToShow.equals("Config"))
		    this.configHelpText();
		else if (textToShow.equals("Connecting"))
		    this.connectingHelpText();
		else if (textToShow.equals("Redefine"))
		    this.redefineHelpText();
		else if (textToShow.equals("Logger"))
		    this.loggerHelpText();
		else    
		    this.noHelpText();
                
		tData.setCaretPosition(0);
                
    		Rectangle bounds = getParent().getBounds();
    		Rectangle abounds = getBounds();
		
    		setLocation(bounds.x + (bounds.width - abounds.width)/ 2,
			    bounds.y + (bounds.height - abounds.height)/2);
	    }
	
	super.setVisible(b);
    }
    
    //{{DECLARE_CONTROLS
    java.awt.Label lTitle = new java.awt.Label();
    java.awt.Button okButton = new java.awt.Button();
    javax.swing.JScrollPane JScrollPane1 = new javax.swing.JScrollPane();
    javax.swing.JTextPane tData = new javax.swing.JTextPane();
    //}}
    
    // Used for addNotify check.
    boolean fComponentsAdjusted = false;
    
    class SymAction implements java.awt.event.ActionListener
    {
	public void actionPerformed(java.awt.event.ActionEvent event)
	{
	    Object object = event.getSource();
	    if (object == okButton)
		okButton_ActionPerformed(event);
	}
    }
    
    void okButton_ActionPerformed(java.awt.event.ActionEvent event)
    {
	// to do: code goes here.
	
	okButton_ActionPerformed_Interaction1(event);
    }
    
    
    void okButton_ActionPerformed_Interaction1(java.awt.event.ActionEvent event)
    {
	try {
	    this.dispose();
	} catch (Exception e) {
	}
    }
    
    class SymWindow extends java.awt.event.WindowAdapter
    {
	public void windowClosing(java.awt.event.WindowEvent event)
	{
	    Object object = event.getSource();
	    if (object == HelpDialog.this)
		HelpDialog_WindowClosing(event);
	}
    }
    
    void HelpDialog_WindowClosing(java.awt.event.WindowEvent event)
    {
	// to do: code goes here.
	
	HelpDialog_WindowClosing_Interaction1(event);
    }
    
    void HelpDialog_WindowClosing_Interaction1(java.awt.event.WindowEvent event)
    {
	try {
	    this.dispose();
	} catch (Exception e) {
	}
    }
    
}
