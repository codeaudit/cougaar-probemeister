/* 
 * <copyright> 
 *   
 *  Copyright 1999-2004 Object Services and Consulting, Inc. 
 *  under sponsorship of the Defense Advanced Research Projects 
 *  Agency (DARPA). 
 *  
 *  You can redistribute this software and/or modify it under the 
 *  terms of the Cougaar Open Source License as published on the 
 *  Cougaar Open Source Website (www.cougaar.org). 
 *  
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 *   
 * </copyright> 
 */ 

/*
		
*/
package com.objs.surveyor.probemeister.gui;

import com.objs.surveyor.probemeister.*;
import com.objs.surveyor.probemeister.instrumentation.*;

import java.awt.*;
import javax.swing.*;
//import com.symantec.itools.javax.swing.JBox;
import javax.swing.event.ListSelectionListener;
import javax.swing.event.ChangeListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ListSelectionEvent;
//import com.objs.surveyor.probemeister.TargetVMDataPanel;
import java.awt.event.WindowListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.File;

import java.util.logging.Level;
import java.util.Hashtable;

import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.RMISecurityManager;
import com.objs.surveyor.probemeister.remote.*;
import com.objs.probemeister.*;


public class MultiJVM extends javax.swing.JFrame 
{
    
    final static Object[] emptyList = new Object[0];
    
    static MultiJVM mgui; //statically accessible handle to this gui
    static public MultiJVM gui() { return mgui; }
    
    //Vector of VMData
    private java.util.Vector waitingVMs = new java.util.Vector();
    private AddRemoteAppDialog addVMDialog =null;
    protected HelpDialog help = null;
    protected MultiJVM gui;
    private boolean rmiON = false;

    //Used to maintain list of logger windows.
    private Hashtable loggerHash = new Hashtable(5);

    SymAction lSymAction = new SymAction();
    ConfigAction lConfigAction = new ConfigAction();
    DefineAction lDefineAction = new DefineAction();
    LoggerAction lLoggerAction = new LoggerAction();
    JFileChooser configChooser = new JFileChooser();
    JFileChooser classChooser = new JFileChooser();
    
    
	private MultiJVM(Frame parent)
	{
	    help = new HelpDialog(this, true);
	    
	    addVMDialog = new AddRemoteAppDialog(this,help);
//	    help.getContentPane().setLocation(2900, 2900);
        gui = this;
        
//		super(parent);
        WindowListener windowListener = new WindowAdapter() {
            public void windowClosing(WindowEvent e) {
                com.objs.surveyor.probemeister.Log.out.info("GUI Window closed, shutting down ProbeMeister...");
                appClosing();
            }
        };
            
		this.addWindowListener(windowListener);
		// This code is automatically generated by Visual Cafe when you add
		// components to the visual environment. It instantiates and initializes
		// the components. To modify the code, only use code syntax that matches
		// what Visual Cafe can generate, or Visual Cafe may be unable to back
		// parse your Java file into its visual environment.
		//{{INIT_CONTROLS
		setJMenuBar(JMainMenu);
		setTitle("ProbeMeister GUI");
		setResizable(false);
		getContentPane().setLayout(null);
		setSize(734,575);
		setVisible(true);
		getContentPane().add(TargetVMTab);
		TargetVMTab.setBounds(8,31,721,456);
		bAcceptVM.setText("Add Available VM");
		getContentPane().add(bAcceptVM);
		bAcceptVM.setBounds(15,502,146,21);
		lWaitingVMs.addItem("None");
		try {
			lWaitingVMs.select(0);
		}
		catch (IllegalArgumentException e) { }

		//$$ JMainMenu.move(1,457);
		jmFile.setText("File");
		jmFile.setActionCommand("File");
		JMainMenu.add(jmFile);
//		jmiBlah.setText("Blah...");
//		jmFile.add(jmiBlah);
		jmiNew.setText("New Project...");
		jmiNew.setActionCommand("New Project...");
		jmFile.add(jmiNew);
		jmiOpen.setText("Open Project...");
		jmiOpen.setActionCommand("Open Project...");
		jmFile.add(jmiOpen);
		jmFile.add(JSeparator1);
		jmiSave.setText("Save");
		jmiSave.setActionCommand("Save");
		jmFile.add(jmiSave);
		jmiSaveAs.setText("Save As...");
		jmiSaveAs.setActionCommand("Save As...");
		jmFile.add(jmiSaveAs);
		jmFile.add(JSeparator2);
		jmiExit.setText("Exit");
		jmiExit.setActionCommand("Exit");
		jmiExit.setMnemonic((int)'Q');
		jmFile.add(jmiExit);
		jmEdit.setText("Edit");
		JMainMenu.add(jmEdit);
		jmView.setText("View");
		JMainMenu.add(jmView);
		jmiViewAll.setText("Class List...");
		jmiViewAll.setActionCommand("Class List...");
		jmView.add(jmiViewAll);
		jmiViewPersist.setText("Persistent Probes...");
		jmView.add(jmiViewPersist);
		jmiSearch.setText("Search...");
		jmView.add(jmiSearch);
		jmVM.setText("Virtual Machines");
		JMainMenu.add(jmVM);
		jmiAttachVM.setText("Attach To VM...");
		jmVM.add(jmiAttachVM);
		jmiAcceptConnection.setText("Accept Connection...");
		jmVM.add(jmiAcceptConnection);
		jmiAutoAccept.setText("Accept All VMs");
		jmVM.add(jmiAutoAccept);
		jmVM.add(new JSeparator());
		jmiHelp.setText("Help...");
		jmVM.add(jmiHelp);
/*
		lBlah.setText("blah blah blah");
		getContentPane().add(lBlah);
		lBlah.setForeground(java.awt.Color.red);
		lBlah.setFont(new Font("Dialog", Font.BOLD, 9));
		lBlah.setBounds(235,534,302,21);
*/
		bAcceptVM.setActionCommand("Add Available VM");
		bAcceptVM.setEnabled(false);
		getContentPane().add(lWaitingVMs);
		lWaitingVMs.setBounds(168,501,197,21);
        //----------------------------------------------
        //------------------------------------------------		
		jmConfig.setText("Configuration");
		JMainMenu.add(jmConfig);
		jmiSaveConfig.setText("Save Configuration...");
		jmConfig.add(jmiSaveConfig);
		jmiApplyConfig.setText("Apply Configuration File...");
		jmConfig.add(jmiApplyConfig);
		jmiDeapplyConfig.setText("De-apply Configuration File...");
		jmConfig.add(jmiDeapplyConfig);
		jmiViewActiveConfig.setText("View Active Configuration");
		jmConfig.add(jmiViewActiveConfig);
		jmiViewConfig.setText("View Configuration File...");
		jmConfig.add(jmiViewConfig);
		jmConfig.add(new JSeparator());
        setConfigMenuEnabled(false); //some items not active on start
		jmiConfigHelp.setText("Help...");
		jmConfig.add(jmiConfigHelp);
		//
		jmReDefineClasses.setText("Re/Define Class");
        setRedefineMenuEnabled(false); //some items not active on start
		JMainMenu.add(jmReDefineClasses);
		jmiRedefineClass.setText("Redefine Class...");
		jmReDefineClasses.add(jmiRedefineClass);
		jmiDefineNewClass.setText("Define Class...");
		jmReDefineClasses.add(jmiDefineNewClass);        
		jmReDefineClasses.add(new JSeparator());
		jmiSendHelp.setText("Help...");
		jmReDefineClasses.add(jmiSendHelp);
		
		//Add in logger menu
//        Boolean log = (Boolean)Globals.globals().get(GlobalVars.USE_PM_AS_LOGGER_MONITOR);
//        if (log.booleanValue()) {
		    jmLogger.setText("Data Collection");
		    JMainMenu.add(jmLogger);
		    jmLoggerWin.setText("Windows");
            jmLogger.add(jmLoggerWin);
		    
		    jmiEmptyLoggerItem.setText("No Active Collectors");
		    jmiEmptyLoggerItem.setEnabled(false);
            jmLoggerWin.add(jmiEmptyLoggerItem);
    		jmLogger.add(new JSeparator());
		    jmiLoggerHelp.setText("Help");
            jmLogger.add(jmiLoggerHelp);
            LoggerManager logMgr = new LoggerManager(this);
//        }
		
		jmFile.addActionListener(lSymAction);
		bAcceptVM.addActionListener(lSymAction);
		SymWindow aSymWindow = new SymWindow();
		this.addWindowListener(aSymWindow);
	    
	}

    ProbeMeisterGUI commander;
    public ProbeMeisterGUI gui2Backend() {return commander;}
    JTabbedPane getTabbedPane() {return TargetVMTab;}
//	public MultiJVM(ProbeMeisterGUI _pm, TargetVMConnector _tvcm)
//	{
//		this((Frame)null);
//        commander = _pm;
//        targetVMConnector = _tvcm;
//	}

	public MultiJVM(ProbeMeisterGUI _pm, String _sTitle)
	{
		this((Frame)null);
		setTitle(_sTitle);
	    commander = _pm;	    
        mgui = this;

	    //Listen for events from the TargetVMConnector
	    TargetVMMgrListener vmMgrListener = new TargetVMMgrListener(this) {
	        public void newVMWaiting(VMData _vmdata) {
	            com.objs.surveyor.probemeister.Log.out.fine("--------------------->vmMgrListener Fired!!! (new VM Waiting)");
                addWaitingVM(_vmdata);	        
	        }
	        /* New VM is being managed, let's add it */
	        public void newTargetVM(VMTVMData _vmdata) {
	            com.objs.surveyor.probemeister.Log.out.fine("--------------------->vmMgrListener Fired!!! (new VM Target event)");
                addTargetVM(_vmdata.getTVM(), _vmdata.getName(), _vmdata.getAddress());  
	        }
	    };
	    TargetVMManager.getMgr().addVMMgrListener(vmMgrListener);

        //To manage state change when tabs change (e.g. enable/disable menus depending upon whether
        // the VM is alive)
	    ChangeListener tabListener = new ChangeListener() {	    
	        public void stateChanged(ChangeEvent e) {
    	        JTabbedPane tab = (JTabbedPane)e.getSource();
    	        TargetVMDataPanel panel = (TargetVMDataPanel)tab.getSelectedComponent();
    	        if (panel != null) 
    	            enableTabMenus(panel.isConnected());      	                
	        }	    
        };
        
        TargetVMTab.addChangeListener(tabListener);	    	    
	    	    
        initFileGUI();	    
        
        //See if we should turn on RMI...
        Boolean rmi = (Boolean)Globals.globals().get(GlobalVars.RMI_ACTIVE);
        if (rmi.booleanValue())
            activateRMI((Integer)Globals.globals().get(GlobalVars.RMI_PORT));
	}

    /* Activates RMI & publishes a RemotePMImpl object */
    private void activateRMI(Integer _portInt) {
          
		com.objs.surveyor.probemeister.Log.out.info("MultiJVM GUI activating RMI...");
        int port = _portInt.intValue();   
        
        //Start the class server
	    com.objs.surveyor.probemeister.Log.out.fine("ProbeMeisterRMI: Starting class server for rmi registry");         
        try {
            String rmiDir = (String)Globals.globals().get(GlobalVars.RMI_FILESERVER_DIR);
            ClassFileServer cfs = new ClassFileServer(port+1, rmiDir);
        } catch (java.io.IOException ioe) {
            com.objs.surveyor.probemeister.Log.out.log(Level.WARNING, "ProbeMeisterRMI: Exception starting classfile server!", ioe);
        }
        
        String host = (String)Globals.globals().get(GlobalVars.RMIREGISTRY);
        
        //Set java.rmi.server.codebase=http://127.0.0.1:<port+1>/
////        String rmiClassServer = "http://127.0.0.1:"+(port+1);
        String rmiClassServer = "http://"+host+":"+(port+1)+"/";
        Globals.globals().put(GlobalVars.RMI_FILESERVER, rmiClassServer);
	    com.objs.surveyor.probemeister.Log.out.fine("ProbeMeisterRMI: setting codebase to "+rmiClassServer); 
        java.util.Properties props = System.getProperties();
        props.put("java.rmi.server.codebase",rmiClassServer);
        String rmiPolicy = (String)Globals.globals().get(GlobalVars.RMI_POLICY_FILE);
        props.put("java.security.policy",rmiPolicy);
        System.setProperties(props);        

        String cb = System.getProperty("java.rmi.server.codebase");
	    com.objs.surveyor.probemeister.Log.out.info("Codebase = "+cb); 
        
        
        // Create and install a security manager 
        if (System.getSecurityManager() == null) { 
	        System.setSecurityManager(new RMISecurityManager()); 
        } 
        try { 
	        RemotePM obj = new RemotePM(this); 
	        // Bind this object instance to the name "HelloServer" 
	        Naming.rebind("//"+host+":"+port+"/ProbeMeisterRMI", obj); 
	        com.objs.surveyor.probemeister.Log.out.fine("ProbeMeisterRMI bound in registry"); 
	        
	        rmiON = true;
	        
        } catch (Exception e) { 
	        com.objs.surveyor.probemeister.Log.out.severe("RemotePM RMI err: " + e.getMessage()); 
	        com.objs.surveyor.probemeister.Log.out.severe("Most likely, the RMI Registry is not running..."); 
	        //e.printStackTrace(); 
        } 

    }
    public boolean isRmiOn() {return rmiON;}

    class ConfigFileFilter extends javax.swing.filechooser.FileFilter {
         
        public boolean accept(File _f) {
            if (_f.getName().endsWith(".pmx")) return true;
            if (_f.isDirectory()) return true;
            return false;
        }
        
        public String getDescription() {return "ProbeMeister Configuration files (pmx)";}        
    }

    class ClassFileFilter extends javax.swing.filechooser.FileFilter {
         
        public boolean accept(File _f) {
            if (_f.getName().endsWith(".class")||_f.getName().endsWith(".jar")||_f.getName().endsWith(".zip")) return true;
            if (_f.isDirectory()) return true;
            return false;
        }
        
        public String getDescription() {return "Java Class files (.class) or Jars/Zips";}        
    }

    /* Set the basic attributes of the FileChooser used for saving/opening config files */
    private void initFileGUI() {
        configChooser.setFileFilter(new ConfigFileFilter());
        classChooser.setFileFilter(new ClassFileFilter());
    }        


	public void addNotify()
	{
		// Record the size of the window prior to calling parents addNotify.
		Dimension size = getSize();

		super.addNotify();

		if (frameSizeAdjusted)
			return;
		frameSizeAdjusted = true;

		// Adjust size of frame according to the insets
		Insets insets = getInsets();
		setSize(insets.left + insets.right + size.width, insets.top + insets.bottom + size.height);
	}

	// Used by addNotify
	boolean frameSizeAdjusted = false;

	//{{DECLARE_CONTROLS
	javax.swing.JTabbedPane TargetVMTab = new javax.swing.JTabbedPane();
	javax.swing.JButton bAcceptVM = new javax.swing.JButton();
	java.awt.Choice lWaitingVMs = new java.awt.Choice();
	javax.swing.JMenuBar JMainMenu = new javax.swing.JMenuBar();
	javax.swing.JMenu jmFile = new javax.swing.JMenu();
	PM_MenuItem jmiBlah = new PM_MenuItem();
	PM_MenuItem jmiNew = new PM_MenuItem();
	PM_MenuItem jmiOpen = new PM_MenuItem();
	javax.swing.JSeparator JSeparator1 = new javax.swing.JSeparator();
	PM_MenuItem jmiSave = new PM_MenuItem();
	PM_MenuItem jmiSaveAs = new PM_MenuItem();
	javax.swing.JSeparator JSeparator2 = new javax.swing.JSeparator();
	PM_MenuItem jmiExit = new PM_MenuItem();
	javax.swing.JMenu jmEdit = new javax.swing.JMenu();
	javax.swing.JMenu jmView = new javax.swing.JMenu();
	PM_MenuItem jmiViewAll = new PM_MenuItem();
	PM_MenuItem jmiViewPersist = new PM_MenuItem();
	PM_MenuItem jmiSearch = new PM_MenuItem();
	javax.swing.JMenu jmVM = new javax.swing.JMenu();
	PM_MenuItem jmiAttachVM = new PM_MenuItem();
	PM_MenuItem jmiAcceptConnection = new PM_MenuItem();
	PM_MenuItem jmiAutoAccept = new PM_MenuItem();
	PM_MenuItem jmiHelp = new PM_MenuItem();
//	javax.swing.JLabel lBlah = new javax.swing.JLabel();
	javax.swing.JMenu jmConfig = new javax.swing.JMenu();
	PM_MenuItem jmiSaveConfig = new PM_MenuItem(lConfigAction);
	PM_MenuItem jmiApplyConfig = new PM_MenuItem(lConfigAction);
	PM_MenuItem jmiDeapplyConfig = new PM_MenuItem(lConfigAction);
	PM_MenuItem jmiViewConfig = new PM_MenuItem(lConfigAction);
	PM_MenuItem jmiViewActiveConfig = new PM_MenuItem(lConfigAction);
	PM_MenuItem jmiConfigHelp = new PM_MenuItem(lConfigAction);
	javax.swing.JMenu jmReDefineClasses = new javax.swing.JMenu();
	PM_MenuItem jmiRedefineClass = new PM_MenuItem(lDefineAction);
	PM_MenuItem jmiDefineNewClass = new PM_MenuItem(lDefineAction);
	PM_MenuItem jmiSendHelp = new PM_MenuItem();
	javax.swing.JMenu jmLogger = new javax.swing.JMenu();
	PM_MenuItem jmiEmptyLoggerItem = new PM_MenuItem(lLoggerAction);
	PM_MenuItem jmiLoggerHelp = new PM_MenuItem(lLoggerAction);
	javax.swing.JMenu jmLoggerWin = new javax.swing.JMenu();
	//}}
	
	
	class SymAction implements java.awt.event.ActionListener
	{
		public void actionPerformed(java.awt.event.ActionEvent event)
		{
			Object object = event.getSource();
			if (event.getActionCommand().equals("Exit")) {
                //Tell all the panels to close up.
                appClosing();
			    System.exit(0);
			}
			else if (event.getSource() == jmiAttachVM) {
			    addVMDialog.setVisible(true);
			    if (addVMDialog.pressedOK()) { // then user pressed "OK", so process
			        String addr = addVMDialog.getAddress();
			        String port = addVMDialog.getPort();
			        String name = addVMDialog.getAppName();
			        try {
			            addr = (addr == "" || addr == null) ? "Local" : addr;
			            name = (name == "" || name == null) ? "UserAdded" : name;
    			        TargetVMManager.getMgr().addTargetVM(name, addr, port);			        
    			    } catch (VMAddressInUseException vmae) {
    			        JOptionPane.showInternalMessageDialog(gui, "That address is already in use...", 
    			        "Error", JOptionPane.INFORMATION_MESSAGE);
    			    }
			    }
			    return;
			} 
			else if (event.getSource() == bAcceptVM) {
			    acceptSelectedWaitingVM();
			}
			else if (event.getSource() == jmiHelp) {
				help.setVisible(true, "Connecting");
			}
//			else if (event.getSource() == jmiBlah) {
//				help.setVisible(true, "Blah");
//			}
			else if (event.getSource() == jmiSendHelp) {
				help.setVisible(true, "Redefine");
			} else
			    com.objs.surveyor.probemeister.Log.out.finest("MultiJVM GUI saw event: "+event.getSource().toString());
		}
	}

	class DefineAction implements java.awt.event.ActionListener
	{
		public void actionPerformed(java.awt.event.ActionEvent event)
		{
			Object object = event.getSource();

            //*****************************
            //Perform validity checks first

			//These need an active VM to proceed, make sure there is one:
			TargetVMConnector tvmc = getActiveDataPanelTVMC();
			if (tvmc == null) { // no active config... should not happen!
    			JOptionPane.showMessageDialog(gui, "A VM (tab) must be selected first...", 
    			"Error", JOptionPane.INFORMATION_MESSAGE);
			    return;
			}

            InstrumentationRecord ir = null;

            String title="";
            boolean defineAction;
			//Display file chooser
			if (event.getSource() == jmiDefineNewClass) {
			//Make sure request queue is working
			    boolean isEnabled = getActiveDataPanel().getConfigRequestsQueue().isFunctional();
			    if (!isEnabled) { // no breakpoint capability
    			    JOptionPane.showMessageDialog(gui, "This feature is not enabled for this remote application.", 
    			    "Error", JOptionPane.INFORMATION_MESSAGE);
			        return;
			    }
			    title = "Select new class to migrate to VM";
			    defineAction = true;
			}else
			if (event.getSource() == jmiRedefineClass) {
			    title = "Select replacement class to migrate to VM";
			    defineAction = false;
			} else
			    return;
			    
            //**********************************			
			//Let user select a file via chooser
            classChooser.setDialogTitle(title);
			File file = openClassFileChooser();
            if (file == null) return;
            if (!file.exists())
                return;

			//**********************************
            //Now create InstrumentationRecordSet 
            //with this action so it can be submitted            
            String filepathname = file.getAbsolutePath();
            String className=filepathname;
            if (filepathname.endsWith(".class")) {
                className= commander.getClassNameFromFile(filepathname);
                if (className == null) {
    			    JOptionPane.showMessageDialog(gui, "Could not determine class name, error processing .class file.", 
    			    "Error", JOptionPane.INFORMATION_MESSAGE);
			        return;
                }
            }
            
            if (defineAction) 
			    ir = new InstrumentationRecord_NewClass(filepathname, className);
			else
			    ir = new InstrumentationRecord_ReplaceClass(filepathname, className);
			
            java.util.Vector v = new java.util.Vector(1);
            v.add(ir);
            InstrumentationRecordSet irs = new InstrumentationRecordSet("userAction", "Sending class to VM", v);

            if (defineAction) {// then queue request
    	        getActiveDataPanel().getConfigRequestsQueue().add(irs);
    			JOptionPane.showMessageDialog(gui, "Your request has been queued for processing.", 
    			"Error", JOptionPane.INFORMATION_MESSAGE);
    	    }
	        else // play request now
	            commander.playConfiguration(tvmc, irs, null);
			
			
        }
    }



	class ConfigAction implements java.awt.event.ActionListener
	{
		public void actionPerformed(java.awt.event.ActionEvent event)
		{
			Object object = event.getSource();
			
			//Display help
			if (event.getSource() == jmiConfigHelp) {
				help.setVisible(true, "Config");
				return;
			}
			
			//The rest of these need an active VM to proceed, make sure there is one:
			TargetVMConnector tvmc = getActiveDataPanelTVMC();
			if (tvmc == null) { // no active config... should not happen!
    			JOptionPane.showMessageDialog(gui, "A VM (tab) must be selected first...", 
    			"Error", JOptionPane.INFORMATION_MESSAGE);
			    return;
			}
			
			else if (event.getSource() == jmiSaveConfig) {
			    
			    //See if there's anything to save first
			    int size = commander.getCurrentConfigurationSize(tvmc);
                if (size ==0) {
    			    JOptionPane.showMessageDialog(gui, "No Instrumentation Records to save...", 
    			    "Error", JOptionPane.INFORMATION_MESSAGE);
                    return;   
                }
                //Let user select a file - present a file chooser
			    File file = saveFileChooser();
                if (file != null) {				
				    //save configuration
				    commander.saveConfiguration(tvmc, file);
				}
			}
			else if (event.getSource() == jmiApplyConfig) {
			    boolean now = true;
			    
				//Let user select a config - present a file chooser
			    File file = openFileChooser();
                if (file == null) return;
                if (!file.exists()) {
                    JOptionPane.showMessageDialog(gui, "Error: File Does Not Exist.", 
                    "Error", JOptionPane.INFORMATION_MESSAGE);
                    return;
                }
                
                int retVal;
                //Check to see if config file contains breakpoint-only actions
                boolean hasBreakpointActions = false;
                try {
                    hasBreakpointActions = 
                        commander.configurationRequiresBreakpoint(file);
                } catch (InstrumentationParsingException ipe) {
                    showParsingErrorDialog(ipe);
                    return;
                } catch (java.io.FileNotFoundException fnf) {} //should not occur

                if (!hasBreakpointActions) { //No breakpoint actions, go ahead & apply
				    retVal = 1;
				} else { //ask user if s/he wants to apply now anyway

                    //Check to see if we CAN apply them - ie. if the request queue is working
			        boolean isEnabled = getActiveDataPanel().getConfigRequestsQueue().isFunctional();
			        if (!isEnabled) { // no breakpoint capability
                        Object[] options = { "Yes", "No", "Help" };
                        retVal = JOptionPane.showOptionDialog(gui, "This configuration contains actions can only be applied at a breakpoint. But it's not functional for the remote app. Apply anyway?", "Apply Anyway?", 
                            JOptionPane.DEFAULT_OPTION, JOptionPane.INFORMATION_MESSAGE,
                            null, options, options[1]);				
                        retVal++; //so it aligns with the numbers used below
			        } else {                    
				        //Apply it now TO CURRENT VM, or queue until a breakpoint comes?
                        Object[] options = { "At a breakpoint", "Apply Now", "Cancel", "Help" };
                        retVal = JOptionPane.showOptionDialog(gui, "This configuration contains actions can only be applied at a breakpoint. Apply when?", "Apply When?", 
                            JOptionPane.DEFAULT_OPTION, JOptionPane.INFORMATION_MESSAGE,
                            null, options, options[1]);				
                    }
                }
                if (retVal==3) {
                    help.setVisible(true, "Redefine");
                    return;
                }
                if (retVal==2) return; //user pressed cancel
				if (retVal==1) //apply config
				    try {
        				commander.playConfiguration(tvmc, file, null);
        			} catch (InstrumentationParsingException ipe) {
        			    showParsingErrorDialog(ipe);
        			}
	            else //add config file to request queue in current DataPanel
	                getActiveDataPanel().getConfigRequestsQueue().add(file);
			}
			//De-apply a selected configuration file.
			else if (event.getSource() == jmiDeapplyConfig) {
    			JOptionPane.showMessageDialog(gui, "You weren't supposed to choose this option... yet.", 
    			"Error", JOptionPane.INFORMATION_MESSAGE);
			}
			else if (event.getSource() == jmiViewConfig) {
			    //Open file chooser
			    File file = openFileChooser();
                if (file != null) {			    				
///    				commander.viewConfigurationFile(file);
                    //Get text from file
                    try {
                        java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.FileReader(file));
                        String line =null;
                        StringBuffer fileStr = new StringBuffer();
                        while (true) {
                            line = reader.readLine();
                            if (line == null) break;
                            fileStr.append(line+"\n");
                        }
                        help.setVisible(fileStr.toString());
                    } catch(Exception e) {
    			        JOptionPane.showMessageDialog(gui, "Error displaying configuration file.", 
    			        "Error", JOptionPane.INFORMATION_MESSAGE);
    			        com.objs.surveyor.probemeister.Log.out.warning("Exception viewing config file: "+e);
                    }
                }
			}
			else if (event.getSource() == jmiViewActiveConfig) {
				///commander.viewCurrentConfiguration(tvmc);				
				
			    int size = commander.getCurrentConfigurationSize(tvmc);
                if (size ==0) {
    			    JOptionPane.showMessageDialog(gui, "No Instrumentation Records to view...", 
    			    "Error", JOptionPane.INFORMATION_MESSAGE);
                    return;   
                }

				help.setVisible(commander.getConfiguration(tvmc));
			}
		}
	}


	class LoggerAction implements java.awt.event.ActionListener
	{
		public void actionPerformed(java.awt.event.ActionEvent event)
		{
			Object object = event.getSource();
			
			//Display help
			if (event.getSource() == jmiLoggerHelp) {
				help.setVisible(true, "Logger");
				return;
			}
			
			JMenuItem mi = (JMenuItem)event.getSource();
			Object o = loggerHash.get(event.getSource());
			if (o != null) {
			    JFrame win = (JFrame) o;   
			    win.setVisible(true);
			}
		}
	}


    /* Displays configuration parsing error dialog to user */
    void showParsingErrorDialog(Exception _e) {
    	JOptionPane.showMessageDialog(gui, "Error applying configuration file.", 
    	"Error", JOptionPane.INFORMATION_MESSAGE);
    	com.objs.surveyor.probemeister.Log.out.warning("Exception applying config file: "+_e);
    }
    
    /* Let user select a class file to open */
    private File openClassFileChooser() {        
        int returnVal = classChooser.showOpenDialog(this);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            File f = classChooser.getSelectedFile();
            if (!f.exists()) {
    			JOptionPane.showMessageDialog(gui, "File does not exist.", 
    			"Error", JOptionPane.INFORMATION_MESSAGE);
                return null;
            }
            else return f;
        } else
            return null;             
    }

    /* Let user select a configuration file to open */
    private File openFileChooser() {        
        int returnVal = configChooser.showOpenDialog(this);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            File f = configChooser.getSelectedFile();
            if (!f.exists()) {
    			JOptionPane.showMessageDialog(gui, "File does not exist.", 
    			"Error", JOptionPane.INFORMATION_MESSAGE);
                return null;
            }
            else return f;
        } else
            return null;             
    }

    /* Let user select a configuration file to save */
    private File saveFileChooser() {        
        int returnVal = configChooser.showSaveDialog(this);
        if(returnVal == JFileChooser.APPROVE_OPTION) {
            File file = configChooser.getSelectedFile();
            if (file.getName().endsWith(".pmx"))
                return file;
            else {
    			JOptionPane.showMessageDialog(gui, "File does not end with .pmx", 
    			"Error", JOptionPane.INFORMATION_MESSAGE);
                return null;
            }
        } else
            return null;             
    }



	class SymWindow extends java.awt.event.WindowAdapter
	{
		public void windowClosed(java.awt.event.WindowEvent event)
		{
			Object object = event.getSource();
			if (object == MultiJVM.this)
				MultiJVM_windowClosed(event);
		}
	}

	void MultiJVM_windowClosed(java.awt.event.WindowEvent event)
	{
		// to do: code goes here.
	    System.exit(0);
	}

//**More content specific methods**

    public void enableTabMenus(boolean _b) {
        setConfigMenuEnabled(_b);
        setRedefineMenuEnabled(_b);
    }

    //These menus should only be enabled when there are data panels
    public void setConfigMenuEnabled(boolean _b) {
        //System.out.println("Setting config buttons..."+_b);        
	    jmiSaveConfig.setEnabled(_b);
	    jmiApplyConfig.setEnabled(_b);
	    jmiDeapplyConfig.setEnabled(_b);
	    jmiViewActiveConfig.setEnabled(_b);
    }
    public void setRedefineMenuEnabled(boolean _b) {
	    jmiRedefineClass.setEnabled(_b);
	    jmiDefineNewClass.setEnabled(_b);
    }


    public void removeVM(TargetVMDataPanel _panel) {
        this.TargetVMTab.remove(_panel);   

        //possibly deactivate menus
        if (this.TargetVMTab.getComponentCount()==0) {
            setConfigMenuEnabled(false);
            setRedefineMenuEnabled(false);
        }
    }

    /* called to add panel for new TargetVMConnector. Removal is handled by panel directly */
    public TargetVMDataPanel addTargetVM(TargetVMConnector _tvmc, String _name, String _addr) {
        
        //activate menus
        if (this.TargetVMTab.getComponentCount()==0) {
            setConfigMenuEnabled(true);
            setRedefineMenuEnabled(true);
        }
        
        TargetVMDataPanel dataPanel = new TargetVMDataPanel(this, _tvmc);
		this.TargetVMTab.addTab((_name ==null ? _addr : _name), dataPanel);
		dataPanel.setBounds(2,24,716,429);
		TargetVMTab.setSelectedComponent(dataPanel);	
		dataPanel.setToolTip(); /* activate tooltip in data panel */
		
		return dataPanel;
    }        

    /* Return all of the data panels */
    public TargetVMDataPanel[] getAllDataPanels() {
        
        //Need to convert array of java.awt.Components to array of panels...
        Object[] x=this.TargetVMTab.getComponents();
        TargetVMDataPanel[] panels = null;
        if (x != null) {
            panels = new TargetVMDataPanel[x.length];                
            for (int i=0;i<x.length; i++) 
                panels[i] = (TargetVMDataPanel)x[i];
        }
        return panels;
        //return (TargetVMDataPanel[]) this.TargetVMTab.getComponents();
    }    
    
    /* Return the current active data panel */
    public TargetVMDataPanel getActiveDataPanel() {
        return (TargetVMDataPanel) this.TargetVMTab.getSelectedComponent();
    }

    /* Return the TargetVMConnector of the current active data panel */
    public TargetVMConnector getActiveDataPanelTVMC() {
        TargetVMDataPanel t = getActiveDataPanel();
        if (t != null)
            return t.getTVMC();
        else 
            return null;
    }
    

    private void addWaitingVM(VMData _vmdata) {
        waitingVMs.add(_vmdata);
        if (lWaitingVMs.getItemCount() == 1) {
            if (lWaitingVMs.getItem(0).equals("None")) 
                lWaitingVMs.remove(0);
        }
        lWaitingVMs.addItem(_vmdata.getName());
        lWaitingVMs.select(_vmdata.getName());
        bAcceptVM.setEnabled(true);
    }

    private void removeWaitingVM(String _name) {
        
        if (waitingVMs.size()==0) {
            com.objs.surveyor.probemeister.Log.out.warning("MultiJVM ERROR: removeWaitingVM -- no VMs in list!");
            return;
        }
        
        VMData vmd = findVMByName(_name);
        if (vmd != null) {
            waitingVMs.removeElement(vmd); //remove from vector
            lWaitingVMs.remove(_name); //remove from gui component
            //If no items left, reinsert "None"
            if (lWaitingVMs.getItemCount() == 0) {
                lWaitingVMs.addItem("None");
                lWaitingVMs.select(0);                
                bAcceptVM.setEnabled(false);
            }
            return;
        }
        com.objs.surveyor.probemeister.Log.out.warning("MultiJVM ERROR: removeWaitingVM -- VM not found: "+vmd.getName());
    }


    private VMData findVMByName(String _name) {
        
        java.util.Enumeration enum = waitingVMs.elements();
        while (enum.hasMoreElements()) {
            VMData vmd = (VMData)enum.nextElement();
            if (vmd.getName().equals(_name))  //found it
                return vmd;
        }
        return null;
    }

    private void acceptSelectedWaitingVM() {
        
        String name = lWaitingVMs.getSelectedItem();
        if (name == null || name.equals("None")) { //nothing selected
            Toolkit.getDefaultToolkit().beep();
            return; 
        }
        VMData vmd = findVMByName(name);
        if (vmd == null) {
            Toolkit.getDefaultToolkit().beep();
            com.objs.surveyor.probemeister.Log.out.warning("MultiJVM ERROR: could not find VM (by name) to add!");
            return;
        }
        
        this.removeWaitingVM(name); // remove item from list
        try {
            TargetVMManager.getMgr().addTargetVM(vmd);
        } catch (Exception vmde) { //App disconnected
            Toolkit.getDefaultToolkit().beep();
    		JOptionPane.showMessageDialog(gui, "Exception while connecting to VM!", 
    		"Error", JOptionPane.INFORMATION_MESSAGE);
            vmde.printStackTrace();
        }
    }


    private void appClosing() {
        
        JTabbedPane tp = getTabbedPane();
        for (int i=0; i < tp.getTabCount(); i++) {
            try {
                TargetVMDataPanel dp = (TargetVMDataPanel) tp.getComponentAt(i);
                dp.close(); //warn each targetVM that we're closing shop.
            } catch (Exception e) {}
        }
        System.exit(0);
    }

    /* Class extends menu items to automatically add an action listener */
    private class PM_MenuItem extends JMenuItem {
        
        private PM_MenuItem() {
            super();
            this.addActionListener(lSymAction);
        }
        /* Add another action listener */
        private PM_MenuItem(java.awt.event.ActionListener _al) {
            super();
            this.addActionListener(_al);
        }
    }
    
    
    public void addLoggerMenuItem(String _port, String _name, javax.swing.JFrame win) {
        
        if (jmLoggerWin.getMenuComponent(0)==jmiEmptyLoggerItem)  //then no loggers yet
            jmLoggerWin.remove(this.jmiEmptyLoggerItem);
        
        //insert new menu item for this logger window
    	PM_MenuItem jmiLoggerItem = new PM_MenuItem(lLoggerAction);
    	jmiLoggerItem.setText(_name);
        jmLoggerWin.insert(jmiLoggerItem, 0);        
        loggerHash.put(jmiLoggerItem, win);
    }
    
    
}

