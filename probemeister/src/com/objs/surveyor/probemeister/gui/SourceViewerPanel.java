/*
 * <copyright>
 *
 *  Copyright 1999-2004 Object Services and Consulting, Inc.
 *  under sponsorship of the Defense Advanced Research Projects
 *  Agency (DARPA).
 *
 *  You can redistribute this software and/or modify it under the
 *  terms of the Cougaar Open Source License as published on the
 *  Cougaar Open Source Website (www.cougaar.org).
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * </copyright>
 */
/*
 * SourceViewer.java
 *
 * Created on August 15, 2002, 1:01 PM
 */
package com.objs.surveyor.probemeister.gui;

import com.objs.surveyor.probemeister.PMMethod;
import com.objs.surveyor.probemeister.probe.ProbeInterface;

import jreversepro.reflect.JMethod;
//import jreversepro.reflect.code.*;
import jreversepro.reflect.JLineOfCode;

import java.util.Iterator;
import java.util.List;
import java.util.Vector;
import javax.swing.DefaultListModel;
import javax.swing.JLabel;
import javax.swing.JList;
import java.awt.Font;
import java.awt.Color;
import java.awt.Component;
import javax.swing.ListCellRenderer;

/**
 *
 * @author  Administrator
 */
public class SourceViewerPanel extends javax.swing.JScrollPane {
    
    boolean userCancelled;
    DefaultListModel dlm;
    TargetVMDataPanel tvmdp;
    ClassTreeNode methodNode = null;
    PMMethod method = null;
    
    static final String PIDSTR = "PROBE ID ";
    
    /** Creates new form SourceViewer 
     *
     */
    public SourceViewerPanel(TargetVMDataPanel _tvmdp) {
        tvmdp = _tvmdp; //for callbacks
        initComponents();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    private void initComponents() {
        
        sourceList = new javax.swing.JList();

        dlm = new javax.swing.DefaultListModel();
        sourceList.setModel(dlm);
        sourceList.setCellRenderer(new CodeRenderer());
        
        //setBorder(new javax.swing.border.EmptyBorder(new java.awt.Insets(15, 15, 15, 15)));
        sourceList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        setViewportView(sourceList);
        //setBounds(this.getBounds());    

    }

    public javax.swing.JList getList() { 
        return sourceList;
    }    

    public ClassTreeNode getNode() { 
        return methodNode;
    }    
    public PMMethod getMethod() { 
        return method;
    }    

    
    // Variables declaration - do not modify
    private javax.swing.JButton bOK;
    private javax.swing.JButton bCancel;
    private javax.swing.JPanel headerPanel;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JPanel sourcePanel;
    private javax.swing.JPanel controlPanel;
    private javax.swing.JList sourceList;
    private javax.swing.JLabel jLabel1;
    // End of variables declaration
    
    boolean seenLastReturn = false;
    
    public void clearSource() {
        dlm.removeAllElements();
    }
    
    public void setSource(JMethod jpm, PMMethod _meth, ClassTreeNode _ctn, boolean showNums) {
        
        SourceInsertionPoint.setVerbose(true);
        this.getVerticalScrollBar().setValue(0);        
        
        seenLastReturn = false;
        dlm.removeAllElements();
        methodNode = _ctn;
        method = _meth;
        boolean initMethod = jpm.getName().startsWith("<");
        
        //sjf List l = jpm.getLinesOfCode();
	List l = jpm.getBlock().getFlattenedCode("");
        
        // .processCode("**OBJS-START**","**OBJS-END**","pmID="); //assume one method for now...
        
        
        String space="          ";
        int len = 0;
        JLineOfCode loc = null;

        //******************************************
        //Preprocess lines marking with block status
        //******************************************
        boolean inBlock = false;
        //boolean inCatchBlock = false;
        for (int i=0; i<l.size(); i++) { 
            try {
                loc = (JLineOfCode)l.get(i);
            } catch (Exception e) {
                System.out.println("Class cast exception - dumping vector ************************");
                for (int ii=0; ii<l.size(); ii++) 
                    System.out.println(""+ii+": "+l.get(ii).getClass().getName());
                return;
            }
/* sjf
            switch (loc.state) {
                case JLineOfCode.ENTRY: 
                    inBlock = true;
                    break;
                case JLineOfCode.EXIT: 
                    inBlock = false;
                    break;
*/
	    //sjf
	    if (loc.isEntryCode()) {
		inBlock = true;
	    } else if (loc.isExitCode()) {
		inBlock = false;
	    }
/*
                case JLineOfCode.CATCH_START: 
                    inCatchBlock = true;
                    break;
                case JLineOfCode.CATCH_END: 
                    inCatchBlock = false;
                    break;

                default: {
                    if (inTryBlock)
                        loc.state = JLineOfCode. TRY_INSIDE;
                    else if (inCatchBlock)
                        loc.state = JLineOfCode.CATCH_INSIDE;
                }
 */
//sjf       }
        }
        
        if (l.size() == 0)  // empty
            dlm.addElement(getSpacer(0,JLineOfCode.INBLOCK, SourceInsertionPoint.PREPEND)); //start insertion pt
        else if (l.size() == 1) { // only return (perhaps)
            dlm.addElement(getSpacer(0,JLineOfCode.INBLOCK, SourceInsertionPoint.PREPEND)); //start insertion pt
            dlm.addElement(l.get(0));
            if (initMethod) //then loc is not a return
                dlm.addElement(getSpacer(-1,JLineOfCode.INBLOCK, SourceInsertionPoint.PREPEND)); //end insertion pt
        } else {
            Vector stack = new Vector(); //guesstimate
            int xx=0;
            int lastPos = l.size()-1;
            //for init methods <init> and <clinit> set seenLastReturn=true
            //since these methods don't have returns!
            if (initMethod) {
                
                loc = (JLineOfCode) l.get((l.size()-1));
                seenLastReturn = true;            
                stack.add(getSpacer(-1,JLineOfCode.INBLOCK,SourceInsertionPoint.PREPEND)); //end insertion pt
                stack.add(loc);                
                lastPos--;
            }
            
            boolean inProbe = false;
            String probeID = null;
            JLineOfCode probe = null;
            for (int j=lastPos; j>=0; j--) { //start at end

                loc = (JLineOfCode)l.get(j);

                //Are we in a probe? If so, this next block of code
                //loops thru (using continue) to collect up the start/end probe info,
                //and creates a single line of code representing the probe.
                //Recall that we're going backwards thru the code!
                if (loc.getStmt().indexOf(ProbeInterface.startMarker)>=0) {
                    inProbe = false; //we'return now exiting the probe
                    probe.setEnd(loc.getEnd());
                    probe.setToIndex(loc.getToIndex());
                    loc = probe;
                    //** FALL THRU NOW **
                }
                else if (loc.getStmt().indexOf(ProbeInterface.endMarker)>=0) {
                    inProbe = true;
                    //Create new loc representing the probe
                    probe = new JProbeLinesOfCode(loc.getStart(),-1,loc.getFromIndex(),-1,"");
                    continue;
                }
                else if (inProbe) {
                    //If this is the probe id, grab it.
                    if (loc.getStmt().indexOf(ProbeInterface.probeIDMarker)>=0) {
                        int pos = loc.getStmt().indexOf(ProbeInterface.probeIDMarker);
                        probe.setStmt(PIDSTR + loc.getStmt().substring(pos+ProbeInterface.probeIDMarker.length(), loc.getStmt().length()-3));
                    }
                    continue;
                }            
                
                //set try catch block status - going bottom up!
                addInsertionEntry(l, stack, j, loc);

    //            String p = loc.p ? "PROBE ---> " : ""; 
                String p = ""; 

                if (showNums) {
                    String num="";
                    if (loc.getStart()>=0) {
                        num = ""+loc.getFromIndex()+"-"+loc.getToIndex()+":";
                        len = num.length();
                        p=num+p;                
                    } else 
                        len = 0;            
                    p=space.substring(len,space.length())+p;
                }
                loc.setViz(p+loc.getStmt());
                stack.add(loc);

            }
            //Add first insertion pt
            stack.add(getSpacer(0,JLineOfCode.INBLOCK, SourceInsertionPoint.PREPEND)); //end insertion pt
            
            //Now pop elements to dlm.
            for (int k=stack.size()-1; k>=0; k--) {
                dlm.addElement(stack.get(k));
            }
        }
    }        
    
    void addInsertionEntry(List l, Vector stack, int pos, JLineOfCode loc) {
        
//System.out.println(">>>>>>>>>>>>>> Loct: from = "+loc.getFromIndex()+" to = "+loc.getToIndex());                        
        //don't insert insertion points until we've seen the last return
        if (!seenLastReturn) {
            if (loc.getStmt().indexOf("return")>=0)
                seenLastReturn = true;
            return;
        }
        
        //if loc.toIndex >= 0 then this stmt is executable & 
        //not decoration [e.g. try, catch, {, } ]
        if (loc.getToIndex() >= 0) { // then a probe can go after it, insert Insertion bar
            //int iState = JLineOfCode;
            //if (loc.state == JLineOfCode.CATCH_INSIDE)
            //    iState = loc.state;
            //else if (loc.state == JLineOfCode.TRY_INSIDE)
            //    iState = loc.state;
            stack.add(getSpacer(loc.getToIndex(), loc.getState(), SourceInsertionPoint.APPEND)); //blank
  //*** OR loc.toIndex with note to insert AFTER
        }
        else { // last loc is non-executable, so check the LOC after this
            JLineOfCode loct = (JLineOfCode)l.get(pos+1);
            //if fromIndex<0 then don't add insertion pt betw. two non-exectuable stmts
            if (loct.getFromIndex()>=0) {
//System.out.println(">>>>>curr=["+loc.viz+"] Grabbing index from next line: "+loct.getFromIndex());
                stack.add(getSpacer(loct.getFromIndex(), loct.getState(), SourceInsertionPoint.PREPEND)); //blank
            }
        }
                
    }
    
    SourceInsertionPoint getSpacer(int _offset, int _state, SourceInsertionPoint.Placement _where) {
        SourceInsertionPoint sip = new SourceInsertionPoint(_offset, _state, _where);
        sip.setVerbose(false);
        return sip;
        
//        JLabel j = new JLabel(".");
//        j.setSize(10,20);
//        return j;
    }
    
    class CodeRenderer extends JLabel
                           implements ListCellRenderer {

        Font CODEFONT = new Font("SanSerif", Font.PLAIN, 12);                               
        Font BOLDCODEFONT = new Font("SanSerif", Font.BOLD, 12);                               
        Font NULLFONT = new Font("SanSerif", Font.PLAIN, 3);                               

        public CodeRenderer() {
            setOpaque(true);
            //setHorizontalAlignment(CENTER);
            //setVerticalAlignment(CENTER);
        }
        public Component getListCellRendererComponent(
            JList list,
            Object value,
            int index,
            boolean isSelected,
            boolean cellHasFocus)
        {
            if (isSelected) {
                setBackground(list.getSelectionBackground());
                setForeground(list.getSelectionForeground());
            } else {
                setBackground(list.getBackground());
                setForeground(list.getForeground());
            }

            setIcon(null);
            setText("");
            if (value instanceof JLineOfCode) { 
                JLineOfCode loc = (JLineOfCode)value;
                String t="[]";
                switch (loc.getState()) {
                    case JLineOfCode.ENTRY: 
                        t="[s]";
                        break;
                    case JLineOfCode.INBLOCK: 
                        t="[i]";
                        break;
                    case JLineOfCode.EXIT: 
                        t="[e]";
                        break;
/*                        
                    case JLineOfCode.CATCH_END: 
                        t="[ce]";
                        break;
                    case JLineOfCode.CATCH_INSIDE: 
                        t="[ci]";
                        break;
                    case JLineOfCode.TRY_INSIDE: 
                        t="[ti]";
                        break;
 */
                }
                
/////                setText(t+loc.viz);
                //sjf setText(loc.viz);
                setText(loc.toString());
                setFont(CODEFONT);
                
                
                if (loc instanceof JProbeLinesOfCode) {
                    setFont(BOLDCODEFONT);
                    setIcon(tvmdp.ICON_PROBE);
                    setBackground(list.getBackground());
                    setForeground(Color.red);
                } else {
                    setBackground(list.getBackground());
                    setForeground(list.getForeground());
                }
                //if (isSelected) {
                //    setBackground(list.getSelectionBackground());
                //    setForeground(list.getSelectionForeground());
                //} else {
                //Don't highlight lines, only space between lines
                //setBackground(list.getBackground());
                //setForeground(list.getForeground());
                //}
            } else if (value instanceof SourceInsertionPoint) { //insertion pt
                setText(value.toString()); //" ");
                setFont(CODEFONT); //NULLFONT);                
                if (isSelected) {
                    setBackground(Color.black);
                    setForeground(Color.black);
                } else {
                    //setBackground(Color.red);
                    //setForeground(Color.red);
                    setBackground(list.getBackground());
                    setForeground(list.getForeground());
                }
            }
            //setIcon(icon);
            return this;
        }
    }   

}
