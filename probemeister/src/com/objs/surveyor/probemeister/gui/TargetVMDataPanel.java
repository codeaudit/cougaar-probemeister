/* 
 * <copyright> 
 *   
 *  Copyright 1999-2004 Object Services and Consulting, Inc. 
 *  under sponsorship of the Defense Advanced Research Projects 
 *  Agency (DARPA). 
 *  
 *  You can redistribute this software and/or modify it under the 
 *  terms of the Cougaar Open Source License as published on the 
 *  Cougaar Open Source Website (www.cougaar.org). 
 *  
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 *   
 * </copyright> 
 */ 
/* 
    Defines the GUI for interacting with one TargetVM
*/
package com.objs.surveyor.probemeister.gui;
import com.objs.surveyor.probemeister.instrumentation.InstrumentationRecordSet;
import com.objs.surveyor.probemeister.instrumentation.InstrumentationRequestQueue;
//import com.objs.surveyor.probemeister.instrumentation.InstrumentationParsingException;
import com.objs.surveyor.probemeister.*;
import com.objs.surveyor.probemeister.remote.*;
import com.objs.surveyor.probemeister.probe.CodeNotAccessibleException;
import com.objs.surveyor.probemeister.instrumentation.*;
import com.objs.surveyor.probemeister.probe.ProbeInterface;
import com.objs.surveyor.probemeister.probe.Location;

import jreversepro.reflect.JMethod;

import java.awt.*;
import javax.swing.*;

import javax.swing.event.TreeSelectionListener;
import javax.swing.event.TreeSelectionEvent;
import java.awt.event.ActionEvent;
import java.awt.event.MouseEvent;
import java.awt.event.MouseAdapter;

import javax.swing.event.ListSelectionListener;
import javax.swing.event.ListSelectionEvent;
import java.util.Vector;
import java.io.File;

import javax.swing.tree.*;

import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.DataFlavor;

//***************
//Not used by PM..
//***************
public class TargetVMDataPanel extends javax.swing.JPanel
{
    
    final static Object[] emptyList = new Object[0];
    TargetVMConnector targetVMConnector = null;
    MultiJVM commander = null;    

    public static ImageIcon ICON_CLASS = null; 
    public static ImageIcon ICON_METHOD = null; 
    public static ImageIcon ICON_PROBE = null; 
    public static ImageIcon ICON_PROBE_STUB = null; 
    public static ImageIcon ICON_UNDEPLOYED_GAUGE_REQUEST = null; 
    public static ImageIcon ICON_DEPLOYED_GAUGE_REQUEST = null; 

    private String gAppName = null;
    public String getAppName() {return gAppName;}
    private String gAppAddr = null;
    public String getAppAddr() {return gAppAddr;}

    PMClass[] classList  = null; //contains all classes 
    PMClass[] filteredClassList  = null; //contains all filtered classes

    static DataFlavor gaugeRequestFlavor = new DataFlavor(GaugeRequest.class, "GaugeRequest");
    static DataFlavor probeFlavor = new DataFlavor(String.class, "string");
    boolean dragging = false; //used by tree listener so it doesn't load method / probes
                             // when a probe/gauge request is dragged across
    boolean mousePressed = false;
    //GaugeRequest selectedGaugeRequest = null;
    boolean firstDrag = true; //required to handle JDK bug
                
    SourceViewerPanel sourceViewer;
    boolean autoLoadSource = false;
    jreversepro.revengine.JSerializer serializer = new jreversepro.revengine.JSerializer();
    
    boolean isConnected() {
        if (this.targetVMConnector == null) return false;
        else return true;
    }
    
	private void initComponents() 
	{
		// This code is automatically generated by Visual Cafe when you add
		// components to the visual environment. It instantiates and initializes
		// the components. To modify the code, only use code syntax that matches
		// what Visual Cafe can generate, or Visual Cafe may be unable to back
		// parse your Java file into its visual environment.
		//{{INIT_CONTROLS
		setLayout(null);
		setSize(700,425);
        
		//setVisible(true);
		bRefresh.setText("Refresh");
		bRefresh.setEnabled(false);
		add(bRefresh);
		bRefresh.setBackground(java.awt.Color.lightGray);
		bRefresh.setBounds(12,242,90,22);
        
		lFilters.setText("Filtering:");
		add(lFilters);
		lFilters.setBounds(505,59,100,19);
        
		add(rbFilterNone);
		rbFilterNone.setBounds(505,84,100,19);
        rbFilterGroup.add(rbFilterNone);
        rbFilterNone.setSelected(true);

        //Filter JDK classes
		add(rbFilterJDK);
		rbFilterJDK.setBounds(505,114,180,19);
        rbFilterGroup.add(rbFilterJDK);

		add(lfilterJDKOther);
		lfilterJDKOther.setBounds(525,133,75,19);

		add(vFilterJDKOther);
		vFilterJDKOther.setToolTipText("space delimited list filters out pkgs");
		vFilterJDKOther.setBounds(600,133,100,19);

		add(lFilterJDKOtherNote);
		lFilterJDKOtherNote.setBounds(600,153,100,19);
        lFilterJDKOtherNote.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        lFilterJDKOtherNote.setFont(new Font("SansSerif", Font.PLAIN, 10));
        
        //Filter In class name
		add(rbFilterIn);
		rbFilterIn.setBounds(505,180,200,19);
        rbFilterGroup.add(rbFilterIn);

		add(vFilterInNames);
		vFilterInNames.setBounds(520,199,160,19);
		vFilterInNames.setToolTipText("space delimited list filters in pkgs/classes");

		add(lFilterInNote);
		lFilterInNote.setBounds(520,219,160,19);
        lFilterInNote.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        lFilterInNote.setFont(new Font("SansSerif", Font.PLAIN, 10));

        //Filter on probes
		add(rbFilterProbe);
		rbFilterProbe.setBounds(505,246,150,19);
        rbFilterGroup.add(rbFilterProbe);

		add(cbFilterProbes);
		cbFilterProbes.setBounds(525,266,200,19);

        //Gauge Deploy Request

        if (commander.isRmiOn()) {
            add(rbGaugeDeploy);
            rbGaugeDeploy.setBounds(505, 296, 200, 19);
            rbFilterGroup.add(rbGaugeDeploy);
            rbGaugeDeploy.setEnabled(false);
        }
        
//		lMethods.setForeground(java.awt.Color.black);
//		lMethods.setBounds(284,32,145,19);
		classScrollPane.setOpaque(true);
		add(classScrollPane);
		classScrollPane.setBounds(12,54,473,180);
//		probesScrollPane.setOpaque(true);
//		add(probesScrollPane);
//		probesScrollPane.setBounds(509,53,181,181);
//		probesScrollPane.getViewport().add(probesJList);
//		probesJList.setBounds(0,0,178,178);
//		add(cProbeTypes);
//		cProbeTypes.setBounds(332,240,146,21);
		lLoadedClasses.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
		lLoadedClasses.setVerticalAlignment(javax.swing.SwingConstants.BOTTOM);
		lLoadedClasses.setText("Loaded Classes");
		add(lLoadedClasses);
		lLoadedClasses.setForeground(java.awt.Color.black);
		lLoadedClasses.setBounds(34,32,145,19);
		vmStatusLabel.setText("VM Status: ");
		add(vmStatusLabel);
		vmStatusLabel.setForeground(new java.awt.Color(102,102,153));
		vmStatusLabel.setBounds(215,242,67,22);
		vmStatus.setText("<status>");
		add(vmStatus);
		vmStatus.setBounds(286,242,110,22);
		bDisconnect.setText("Disconnect");
		bDisconnect.setActionCommand("Disconnect");
		bDisconnect.setEnabled(false);
		add(bDisconnect);
		bDisconnect.setBounds(375,242,110,21);
		bResume.setText("Resume");
		bResume.setActionCommand("Resume");
		bResume.setEnabled(false);
		add(bResume);
		bResume.setForeground(new java.awt.Color(102,102,153));
		bResume.setBounds(121,242,89,22);
		
		//AVAILABLE PROBES LIST
		lAvailableProbes.setText("Available Probes:");
		add(lAvailableProbes);
		lAvailableProbes.setBounds(12,275,150,22);
		
		probeListPane.setOpaque(true);
		add(probeListPane);
		probeListPane.setBounds(12,297,200,90);
		//probeList.setTransferHandler(new TransferHandler("text"));
        java.awt.event.MouseListener ml2 = new MouseAdapter() {
            public void mousePressed(MouseEvent e) {
                JComponent c = (JComponent)e.getSource();
                //System.out.println("object is of type = "+c.getClass().getName());
                TransferHandler th = c.getTransferHandler();
                dragging = true;
                //System.out.println("dragging = true");
                th.exportAsDrag(c, e, TransferHandler.COPY);
            }
        };
        probeList.addMouseListener(ml2);		
		probeList.setDragEnabled(true);
		classTree.setTransferHandler(new ProbeDNDHandler(null));
		probeList.setCellRenderer(new ProbeListCellRenderer());
		probeList.setTransferHandler(new ProbeDNDHandler(null));		
                
		lDragProbes.setText("(Drag Probe To Method)");
		add(lDragProbes);
		lDragProbes.setBounds(12,390,200,15);
        lDragProbes.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        lDragProbes.setFont(new Font("SansSerif", Font.PLAIN, 10));
		//}}
		
		
		
	
		//{{REGISTER_LISTENERS
		SymAction lSymAction = new SymAction();
		bRefresh.addActionListener(lSymAction);
		
		cbFilterProbes.addActionListener(lSymAction);
		rbFilterNone.addActionListener(lSymAction);
		rbFilterJDK.addActionListener(lSymAction);
		rbFilterIn.addActionListener(lSymAction);
		rbFilterProbe.addActionListener(lSymAction);
		
		bDisconnect.addActionListener(lSymAction);
		bResume.addActionListener(lSymAction);
		//}}
		SelectionListener listListener = new SelectionListener();
		
    	classTree.setRootVisible(false);
        classTree.getSelectionModel().setSelectionMode
                (TreeSelectionModel.SINGLE_TREE_SELECTION);

        //Listen for when the selection changes.
        classTree.addTreeSelectionListener(new ClassTreeListener());
        classTree.setCellRenderer(new ClassTreeCellRenderer());		
		classTree.addMouseListener(new PopupTrigger());
    	classTree.setModel(treeModel);

        //Set change listener to disable rbGaugeDeploy when any 
        //other RadioButton is selected
        
		
	}
        

    void initProbeList() {
        
        String[] probeTypeChoices = commander.gui2Backend().getProbeTypeList();
            probeList.setListData(probeTypeChoices);
            if (true) return;
        if (probeTypeChoices != null) {
            int size = probeTypeChoices.length;
            JLabel[] probes = new JLabel[size];
            for (int i=0; i<size; i++) 
                //convert to JLabels so they can be dragged...
                probes[i] = new JLabel(probeTypeChoices[i]);
            
            probeList.setListData(probes);
        }
    }

    void initPopupMenus() {
    
        //methodPopupMenu
        JMenu addProbeMI = new JMenu("Add Probe");
        methodPopupMenu.add(addProbeMI);
        
        methodPopupMenu.setDefaultLightWeightPopupEnabled(false);
        
        //Add probe types as children to add menu
        String[] probeTypeChoices = commander.gui2Backend().getProbeTypeList();
        if (probeTypeChoices != null) {
            for (int i=0; i<probeTypeChoices.length; i++) {
                Action addProbeAction = new AddProbeAction(probeTypeChoices[i]);
                addProbeMI.add(addProbeAction);
            }
        } else
            addProbeMI.add(new JMenuItem("No Probe Types Found"));
        
        //probePopupMenu
        Action delProbeAction = new AbstractAction("Delete Probe") {
            public void actionPerformed(ActionEvent _e) {
                if (clickedPath == null) return;
                ClassTreeNode node = 
                    (ClassTreeNode)clickedPath.getLastPathComponent();                
                if (node != null) {
                    if (node.getUserObject() instanceof PMProbe) {
                        PMProbe probe = (PMProbe)node.getUserObject();
                        bRemoveProbe_ActionPerformed(probe, node);                
                    }
                }
            }
        };
        probePopupMenu.add(delProbeAction);

        Action probeInfoAction = new AbstractAction("Probe Info") {
            public void actionPerformed(ActionEvent _e) {
                if (clickedPath == null) return;
                ClassTreeNode node = 
                    (ClassTreeNode)clickedPath.getLastPathComponent();                
                if (node != null) {
                    if (node.getUserObject() instanceof PMProbe) {
                        PMProbe probe = (PMProbe)node.getUserObject();
                        bProbeInfo_ActionPerformed(probe, node);                
                    }
                }
            }
        };
        probePopupMenu.add(probeInfoAction);
    }

    /*  
     * Init the source code viewer
     *
     */
    void initSourceViewerPanel() {     
        
        JLabel title = new JLabel("Source Code:");
        add(title);
        title.setBounds(230,275,80,22);

        final JCheckBox autoLoad = new JCheckBox("Auto-Load?");
        add(autoLoad);
        autoLoad.setBounds(320,275,100,22);
        autoLoad.addActionListener(new java.awt.event.ActionListener() {
           public void actionPerformed(ActionEvent e) { 
              autoLoadSource = autoLoad.isSelected();
              System.out.println(">>>>>>>>>>>>>>>>> autoload = "+autoLoadSource);
           }
        });
        sourceViewer = new SourceViewerPanel(this);      
        sourceViewer.setBounds(230,297, 465,120);
        add(sourceViewer); 
	sourceViewer.getList().setTransferHandler(new ProbeDNDHandler(null));
        
    }
    
    
    
//	public TargetVMDataPanel(TargetVMConnector _tvcm)
//	{
//		this();
//	    targetVMConnector = _tvcm;
//	}

    /* Called after panel is added to Tabbed pane */
    public void setToolTip() {
        int ind = commander.getTabbedPane().getSelectedIndex();
        commander.getTabbedPane().setToolTipTextAt(ind, gAppAddr );
    }

	public TargetVMDataPanel(MultiJVM _parent, TargetVMConnector _tvmc)
	{
        
	    targetVMConnector = _tvmc;
	    commander = _parent;	    
            initComponents();
            
	    this.gAppName = _tvmc.getName();
	    this.gAppAddr = _tvmc.getAddress();
        
	    configRequestsQueue = new InstrumentationRequestQueue(targetVMConnector, 5);
	   
	    try {
            ICON_CLASS = 
                new ImageIcon(this.getClass().getResource("classNodeIcon.gif"));
            ICON_METHOD = 
                new ImageIcon(this.getClass().getResource("methodNodeIcon.gif"));
            ICON_PROBE = 
                new ImageIcon(this.getClass().getResource("simpleProbeIcon.gif"));
            ICON_PROBE_STUB = 
                new ImageIcon(this.getClass().getResource("probeStubNodeIcon.gif"));
            ICON_UNDEPLOYED_GAUGE_REQUEST = 
                new ImageIcon(this.getClass().getResource("gaugeRequestDeployed.gif"));
            ICON_DEPLOYED_GAUGE_REQUEST =
                new ImageIcon(this.getClass().getResource("gaugeRequestUndeployed.gif"));
	    } catch (NullPointerException npe) {
	        if (ICON_CLASS== null) { //didn't find icons, try local 
	        //No errors reported if not found...
            ICON_CLASS = 
                new ImageIcon("classNodeIcon.gif");
            ICON_METHOD = 
                new ImageIcon("methodNodeIcon.gif");
            ICON_PROBE = 
                new ImageIcon("simpleProbeIcon.gif");
            ICON_PROBE_STUB = 
                new ImageIcon("probeStubNodeIcon.gif");
            ICON_UNDEPLOYED_GAUGE_REQUEST = 
                new ImageIcon("gaugeRequestUndeployed.gif");
            ICON_DEPLOYED_GAUGE_REQUEST =
                new ImageIcon("gaugeRequestDeployed.gif");	        
	        }   
	    }
	    
	    //init Probe Type choices 
	    //1. Insert "Select Probe Type..."
//	    this.cProbeTypes.add("Select Probe Type...");	        
	    //2. Get & add the probe types
//	    String[] probeTypeChoices = commander.gui2Backend().getProbeTypeList();
//	    for (int i=0; i<probeTypeChoices.length; i++) {
//	        this.cProbeTypes.add(probeTypeChoices[i]);	        
//	    }
        initPopupMenus();
        initProbeList();
        if (!commander.isRmiOn())
            initSourceViewerPanel();
        	    
	    //Listen for events from the TargetVMConnector
	    TargetVMListener vmListener = new TargetVMListener(this) {
	        String name = ((TargetVMDataPanel)o).targetVMConnector.getName();
	        public void classListUpdated(TargetVMEvent e) {
	            Object c = (Object)e.getSource();
	            addNewClass(commander.gui2Backend().getPMClass(c, targetVMConnector));
	            //System.out.println("["+name+"]--------------------->vmListener Fired!!! (vm classListUpdated)");
	            //bRefresh.setEnabled(true); //alow user to update displayed list
	            enableFiltering(true);
	        }
	        public void vmConnected(TargetVMEvent e) { //Load classes
	            com.objs.surveyor.probemeister.Log.out.finest("["+name+"]--------------------->vmListener Fired(vm Connected)!!!");
	            ((TargetVMDataPanel)o).setStatus("Connected"); 
                ((TargetVMDataPanel)o).bDisconnect.setEnabled(true);
            }
	        public boolean vmStartedInterrupted(TargetVMEvent e) { //Load classes
	            com.objs.surveyor.probemeister.Log.out.finest("["+name+"]--------------------->vmListener Fired(vm Started Interrupted)!!!");
	            ((TargetVMDataPanel)o).setStatus("Interrupted"); 
	            ((TargetVMDataPanel)o).bResume.setEnabled(true);
	            return false; //we want to control resumption of thread
            }
            /* Sets the tab for this VM to the name passed in by the Target VM */
            public void vmUpdatedVMParamsEvent(TargetVMEvent e) {
                TargetVMCLParams p = (TargetVMCLParams)e.getSource();
                gAppName = p.get(TargetVMCLParams.APPNAME);
                gAppAddr = p.get(TargetVMCLParams.APPADDR);

                if (gAppName != null) {
                    String title = gAppName;
                    int ind = commander.getTabbedPane().getSelectedIndex();
                    commander.getTabbedPane().setToolTipTextAt(ind, (gAppAddr != null) ? gAppAddr : "UNKNOWN_CL");
                    commander.getTabbedPane().setTitleAt(ind, title);
                }
            }
	        public void vmStartedRunning(TargetVMEvent e) { //Load classes
	            com.objs.surveyor.probemeister.Log.out.finest("["+name+"]--------------------->vmListener Fired(vm Started Running)!!!");
	            ((TargetVMDataPanel)o).setStatus("Running"); 
	            ((TargetVMDataPanel)o).bResume.setEnabled(false);
	            ((TargetVMDataPanel)o).setClassList(commander.gui2Backend().getClassList(targetVMConnector));
            }
	        public void vmDisconnected(TargetVMEvent e) {
	            if (((TargetVMDataPanel)o).targetVMConnector == null) return; //already disconnected
	            com.objs.surveyor.probemeister.Log.out.finest("["+name+"]--------------------->vmListener Fired(vm Disconnected)!!!");
	            ((TargetVMDataPanel)o).setStatus("Disconnected"); 
	            ((TargetVMDataPanel)o).bDisconnect.setText("Remove"); 
	            ((TargetVMDataPanel)o).targetVMConnector = null;
	            ((TargetVMDataPanel)o).manageState(3); //clear all windows
	            ((TargetVMDataPanel)o).commander.enableTabMenus(false); //disable VM-related menus in parent
	            JOptionPane.showMessageDialog(commander, 
	                    "The Target VM is no longer connected.", "Information", JOptionPane.INFORMATION_MESSAGE);
	        }
	        public boolean vmInterrupted(TargetVMEvent e) {
	            ((TargetVMDataPanel)o).setStatus("Interrupted"); 
	            com.objs.surveyor.probemeister.Log.out.finest("["+name+"]--------------------->vmListener Fired(vm Interrupted)!!!");
	            ((TargetVMDataPanel)o).bResume.setEnabled(true);
	            return false; //we want to control resumption of thread
	        }
	        public void vmResumed(TargetVMEvent e) {
	            com.objs.surveyor.probemeister.Log.out.finest("["+name+"]--------------------->vmListener Fired(vm Resumed)!!!");
	            ((TargetVMDataPanel)o).setStatus("Running"); 
	            ((TargetVMDataPanel)o).bResume.setEnabled(false);
	        }
	        public boolean vmBreakpointEvent(TargetVMEvent e) {
	            com.objs.surveyor.probemeister.Log.out.finest("["+name+"]--------------------->vmListener Fired(vm BreakpointEvent)!!!");
                com.sun.jdi.event.BreakpointEvent be = (com.sun.jdi.event.BreakpointEvent)e.getSource();
                if (configRequestsQueue.size() > 0) {
                    
	                JOptionPane.showMessageDialog(commander, 
	                        "Applying Queued Requests.", "Information", JOptionPane.INFORMATION_MESSAGE);
                    String successes="";
                    int successCount = 0;                    
                    InstrumentationRecordSet[] irss = null;
                    
                    try {
                        irss = configRequestsQueue.processQueue(be);
                    } catch (Exception ex) {
                        com.objs.surveyor.probemeister.Log.out.severe("TargetVMDataPanel.breakpointException -- saw exception: "+ex);
                    }
                    if (irss == null) {
    			        JOptionPane.showMessageDialog(commander, "Errors occurred while accessing configuration request.", 
    			        "Error", JOptionPane.INFORMATION_MESSAGE);
    			        com.objs.surveyor.probemeister.Log.out.severe("Error applying config file");
                    } else {
                        
                        for (int j=0; j<irss.length; j++) { //examine results & report back to user
                        
                            //see if it's null, if not ask user if they want to see the errors
                            if (irss[j] == null) {
    			                JOptionPane.showMessageDialog(commander, "Errors occurred while accessing configuration request "+(j+1), 
    			                "Error", JOptionPane.INFORMATION_MESSAGE);
    			                com.objs.surveyor.probemeister.Log.out.severe("Error applying config file");
                            }
                            else { 
                                if (irss[j].getErrorCount() > 0) { //then some records were not applied
                                
                                    Object[] options = { "Yes", "No" };
                                    int retVal = JOptionPane.showOptionDialog(commander, "Errors occurred while applying configuration request"+(j+1), "View Failed Entries?", 
                                        JOptionPane.DEFAULT_OPTION, JOptionPane.INFORMATION_MESSAGE,
                                        null, options, options[0]);				
                                    if (retVal==0) { //user pressed "yes"
                                        try {
                                            commander.help.setVisible(irss[j].serializeSet());
                                        } catch(Exception ee) {
    			                            JOptionPane.showMessageDialog(commander, "Error displaying configuration errors.", 
    			                            "Error", JOptionPane.INFORMATION_MESSAGE);
    			                            com.objs.surveyor.probemeister.Log.out.severe("Exception viewing config file: "+ee);
                                        }
                                    }
                                } else {
                                    successes += " "+(j+1);
                                    successCount++;
                                }

                                //Update class list
                                updateClassList();
                                
                                //Update list of probes based upon applied InstrumentationRecords.
                                for (int k=0; k<irss[j].getSize(); k++) {                      
                                    InstrumentationRecord ir = irss[j].getRecord(k);
                                    if (ir.getError() != null) continue; //ignore error records
                                    if (ir instanceof InstrumentationRecord_Probe) {
                                        InstrumentationRecord_Probe irp = (InstrumentationRecord_Probe)ir;
                                        //update list of probes...
                                        updateProbesInMethod(irp.getClassName(), irp.getMethodName());
                                    } else 
                                    if (ir instanceof InstrumentationRecord_Stub) {
                                        InstrumentationRecord_Stub irp = (InstrumentationRecord_Stub)ir;
                                        //update list of probes...
                                        boolean  done = updateProbesInMethod(irp.getClassName(), irp.getMethodName());
                                    }
                                    
                                }
                            }
                        }                  
                    }
                    //Summarize total of completely successfully applied requests
                    if (successCount >0) {
                        if (successCount == 1) //let user know 
    			            JOptionPane.showMessageDialog(commander, "The queued request was applied completely.", 
    			            "Status", JOptionPane.INFORMATION_MESSAGE);
                        else if (successCount > 1) //let user know 
    			            JOptionPane.showMessageDialog(commander, "The queued requests "+successes+" were applied completely.", 
    			            "Status", JOptionPane.INFORMATION_MESSAGE);
                    }                                       
	            }
	            return true; //done handling, OK to resume thread/app
            }	        
	    };
	    targetVMConnector.addVMListener(vmListener);
	    
	    //Fire connected, as the tvmc must already be connected before the
	    //dataPanel is created... (so the classes are loaded)
	    //vmListener.vmConnected(new TargetVMEvent(targetVMConnector));

	    //RMI GUI Parts
		//=============
		
		if (commander.isRmiOn()) { //then add RMI parts
		    addRMIGUIStuff();		    
		}
	    
	}
	
	void addRMIGUIStuff() {
	    
		    lGaugeDeploy.setText("Gauge Deployment Requests");
		    add(lGaugeDeploy);
		    lGaugeDeploy.setBounds(240,275,200,22);		    
    		
    		gaugeDeployList.setDragEnabled(true);
    		gaugeDeployList.setTransferHandler(new ProbeDNDHandler(null));
    		
		    gaugeDeployListPane.setOpaque(true);
		    add(gaugeDeployListPane);
		    gaugeDeployListPane.setBounds(240,297,250,90);
          
            java.awt.event.MouseListener ml3 = new MouseAdapter() {
                public void mouseClicked(MouseEvent e){
                    //dragging = false; //used by tree listener so it doesn't load method / probes
                                // when a probe/gauge is dragged across them
                    //System.out.println("dragging = false -- mouse clicked");

                    if(e.getClickCount() == 2){
                    int index = gaugeDeployList.locationToIndex(e.getPoint());
                    if (index<0) return;
                        ListModel dlm = gaugeDeployList.getModel();
                        
                        GaugeRequest gr = (GaugeRequest)dlm.getElementAt(index);
                        gaugeDeployList.ensureIndexIsVisible(index);
                        if (gr != null) {
                            GaugeRequestDialog grd = new GaugeRequestDialog(commander, gr);
                            //Get Past Locations
                            GaugeRequestLocation[] pastLocs = lookupPastGaugeRequestLocations(gr);
                            if (pastLocs != null)
                                grd.setPastLocationsList(pastLocs);
                            //set display
                            grd.show();       
                            if (grd.getDeployGauge())
                                deployGaugeRequestFromDialog(gr, grd.getSelectedRecommended(), grd.getSelectedPast());
                        }
                    }
                }
            };
            
            /* When dragging occurs, it exports the GaugeRequest to be dropped
             * onto a method.
             */
            java.awt.event.MouseMotionListener ml4 = new java.awt.event.MouseMotionAdapter() {
                public void mouseDragged(MouseEvent e) { 
                    JList c = (JList)e.getSource();
                    TransferHandler th = c.getTransferHandler();
                    dragging = true;
                   
                    //System.out.println("dragging = true");
                    th.exportAsDrag(c, e, TransferHandler.COPY);
                }
            };
            
            gaugeDeployList.addMouseListener(ml3);		
            gaugeDeployList.addMouseMotionListener(ml4);		
            gaugeDeployList.setModel(new DefaultListModel());
            
		    bActivateGaugeRequest.setText("Activate");
		    bActivateGaugeRequest.setActionCommand("Activate");
		    bActivateGaugeRequest.setEnabled(false);
		    add(bActivateGaugeRequest);
		    bActivateGaugeRequest.setBounds(240,390,110,21);

		    bRemoveGaugeRequest.setText("Remove");
		    bRemoveGaugeRequest.setActionCommand("Remove");
		    bRemoveGaugeRequest.setEnabled(false);
		    add(bRemoveGaugeRequest);
		    bRemoveGaugeRequest.setBounds(360,390,110,21);	
    
            //Add listeners
            GaugeActionListener gal = new GaugeActionListener();
            bRemoveGaugeRequest.addActionListener(gal);
            bActivateGaugeRequest.addActionListener(gal);

            //Add GaugeRequestListCellRenderer
            gaugeDeployList.setCellRenderer(new GaugeRequestListCellRenderer());
                        
            //Test data
            GaugeRequestLocationInterface[] grl = new GaugeRequestLocationInterface[1];
            try {
                grl[0]=new GaugeRequestLocation("VM Y", "Class C", "Method M");                
                processGaugeDeployRequest(new GaugeRequest("gaugeName","myDeployID","TCP Thruput",
                    "probe X", "plugClass", "plugMeth", "VMName", grl, 0, null));
                GaugeRequest g2 = new GaugeRequest("gaugeName","deployID","TCP Thruput",
                    "probe X", "plugClass", "plugMeth", "VMName", grl, 1, null);
                g2.setDeployed(true);
                processGaugeDeployRequest(g2);
            } catch (java.rmi.RemoteException re) {
                System.out.println("RemoteException!!");
                re.printStackTrace();
            }
		    
    }	    
	
	/* returns queue that holds Configuration requests waiting for a breakpoint
	 */
	InstrumentationRequestQueue configRequestsQueue = null;
	public InstrumentationRequestQueue getConfigRequestsQueue() { return configRequestsQueue; }
		
	public TargetVMConnector getTVMC() {return targetVMConnector;}
	
	/* Called when app is terminating. We want to make sure that the
	 * target VM is running when we quit.
	 */
	void close() {
	    if (targetVMConnector != null) {
	        if (targetVMConnector.vm() != null)
    	        targetVMConnector.vm().resume();
    	        targetVMConnector.vm().dispose();
    	}
	}

    private Vector newClassNodes = new Vector(100,50);

    /* Called to add new classes to the class tree */	
	public void addNewClass(PMClass _pm) {	    
	    if (_pm == null) return;
	    //Make sure we're not adding a duplicate. - just search vector which will likely contain dups
	    java.util.Enumeration kids =  newClassNodes.elements();   //treeRoot.children();
        while (kids.hasMoreElements()) {
            ClassTreeNode ctn = (ClassTreeNode)kids.nextElement();
            if (_pm.name().equals(ctn.getUserObject().toString())) {
//                System.out.println("TargetVMDataPanel.addNewClass::Duplicate RT found: "+_pm.name());
                return;
            }
        }

        synchronized(newClassNodes) {
    	    newClassNodes.addElement(ClassTreeNode.createClassNode(_pm));
        }

//	    treeModel.nodesWereInserted(treeRoot, indicies);
	    
//        treeModel.insertNodeInto(ClassTreeNode.createClassNode(_pm), 
//                treeRoot, treeRoot.getChildCount());

//        synchronized(treeRoot) {
//            treeModel.insertNodeInto(ClassTreeNode.createClassNode(_pm), 
//                    treeRoot, treeModel.getChildCount(treeRoot));
//        }
	}
	    
	/* Set the list of classes used in this GUI. Call ONCE. */
	public void setClassList(PMClass[] _clist) {

        if (treeRoot.getChildCount() > 0) {        
            com.objs.surveyor.probemeister.Log.out.warning("TargetVMDataPanel.setClassList:: cannot execute, tree has children.");
            return;
        }
        
	    treeRoot.removeAllChildren();
	    classTree.repaint();
	    
	    int[] indicies = new int[_clist.length];
	    int pos=0;
        for (int i=0; i<_clist.length; i++) {
            pos = treeRoot.getChildCount();
            treeRoot.add(ClassTreeNode.createClassNode(_clist[i]));
            indicies[i]=pos;
//            synchronized(treeRoot) {
//                treeModel.insertNodeInto(ClassTreeNode.createClassNode(_clist[i]),
//                            treeRoot, treeModel.getChildCount(treeRoot));
//            }
        }
        treeModel.nodesWereInserted(treeRoot, indicies);
        
        classTree.repaint();
        if (!classTree.isExpanded(rootTreePath)) {
            classTree.expandPath(rootTreePath);   
        }            
        return;	    
	}

    /* Set the value of the status string */
	void setStatus(String _s) { vmStatus.setText(_s); }


	public void addNotify()
	{
		// Record the size of the window prior to calling parents addNotify.
		Dimension size = getSize();

		super.addNotify();

		if (frameSizeAdjusted)
			return;
		frameSizeAdjusted = true;

		// Adjust size of frame according to the insets
		Insets insets = getInsets();
		setSize(insets.left + insets.right + size.width, insets.top + insets.bottom + size.height);
	}

	// Used by addNotify
	boolean frameSizeAdjusted = false;

	//{{DECLARE_CONTROLS
	java.awt.Button bRemoveProbe = new java.awt.Button();
	javax.swing.JLabel lProbes = new javax.swing.JLabel();
	javax.swing.JLabel lMethods = new javax.swing.JLabel();

	//TREE
	ClassTreeNode treeRoot = ClassTreeNode.createRootNode("Classes") ;
	ClassTreeModel treeModel = new ClassTreeModel(treeRoot);
	javax.swing.JTree classTree = new javax.swing.JTree(treeRoot);

	
	javax.swing.JScrollPane classScrollPane = new javax.swing.JScrollPane(classTree);
	TreePath rootTreePath = new TreePath(treeRoot);
	JPopupMenu methodPopupMenu = new JPopupMenu();
	JPopupMenu probePopupMenu = new JPopupMenu();
	TreePath clickedPath;
	
	javax.swing.JLabel lLoadedClasses = new javax.swing.JLabel();
	javax.swing.JLabel vmStatusLabel = new javax.swing.JLabel();
	javax.swing.JLabel vmStatus = new javax.swing.JLabel();
	javax.swing.JButton bDisconnect = new javax.swing.JButton();
	javax.swing.JButton bResume = new javax.swing.JButton();
	javax.swing.JButton bRefresh = new javax.swing.JButton();


    //Available Probes
	javax.swing.JLabel lAvailableProbes = new javax.swing.JLabel();
    javax.swing.JList probeList = new javax.swing.JList();
    javax.swing.JScrollPane probeListPane = new javax.swing.JScrollPane(probeList);
	javax.swing.JLabel lDragProbes = new javax.swing.JLabel();

    //Filter Remote Gauge Deploy Request
	javax.swing.JRadioButton rbGaugeDeploy = new javax.swing.JRadioButton("Gauge Deploy Request");
    //Filter None
	javax.swing.JRadioButton rbFilterNone = new javax.swing.JRadioButton("None");
	//Filter Probes parts
	javax.swing.JRadioButton rbFilterProbe = new javax.swing.JRadioButton("Show All Probes");
	javax.swing.JCheckBox cbFilterProbes = new javax.swing.JCheckBox("Hide methods with no probes");

	//Filter JDK parts
	javax.swing.JRadioButton rbFilterJDK = new javax.swing.JRadioButton("Exclude JDK Packages");
	javax.swing.JLabel     lfilterJDKOther      = new javax.swing.JLabel("Other Pkgs:");
    javax.swing.JTextField vFilterJDKOther      = new javax.swing.JTextField(50); 
    javax.swing.JLabel     lFilterJDKOtherNote  = new javax.swing.JLabel("(pkg prefixes)");    

	//Filter In parts
	javax.swing.JRadioButton rbFilterIn = new javax.swing.JRadioButton("Include Classes Containing:");
    javax.swing.JTextField vFilterInNames      = new javax.swing.JTextField(75); 
    javax.swing.JLabel     lFilterInNote  = new javax.swing.JLabel("(c*<class> or p*<pkg prefix>)");

    javax.swing.ButtonGroup rbFilterGroup = new javax.swing.ButtonGroup();
	javax.swing.JLabel lFilters = new javax.swing.JLabel();
	javax.swing.JLabel llFilters = new javax.swing.JLabel();

    //RMI Gauge Requests
	javax.swing.JButton bRemoveGaugeRequest = new javax.swing.JButton();
	javax.swing.JButton bActivateGaugeRequest = new javax.swing.JButton();
	javax.swing.JList gaugeDeployList = new javax.swing.JList();
	javax.swing.JScrollPane gaugeDeployListPane = new javax.swing.JScrollPane(gaugeDeployList);
	javax.swing.JLabel lGaugeDeploy = new javax.swing.JLabel();

    class ClassTreeCellRenderer extends JLabel implements TreeCellRenderer {

        protected Color selectionColor;
        protected Color nonselectionColor;
        protected Color bkselectionColor;
        protected Color bknonselectionColor;
        protected Color borderSelectionColor;
        protected boolean m_selected;

        java.awt.Font hasNoKidsFont = new Font("SanSerif", Font.PLAIN, 12);
        java.awt.Font hasKidsFont =   new Font("SanSerif", Font.BOLD, 12);
        
        public ClassTreeCellRenderer() { 
            
            super(); 
            selectionColor = Color.black;
            nonselectionColor = Color.black;
            bkselectionColor = Color.yellow;
            bknonselectionColor = Color.white;
            borderSelectionColor = UIManager.getColor("Tree.selectionBorderColor");
            setOpaque(false);


        }

        public Component getTreeCellRendererComponent(JTree tree,
                    Object value, boolean sel, boolean expanded,
                    boolean leaf, int row, boolean hasFocus) {     
                       
            ClassTreeNode node = (ClassTreeNode)value;
            Object obj = node.getUserObject();
            if (obj!= null)
                this.setText(obj.toString());
            else { 
                this.setText("Classes");
                //classTree.expandPath(rootTreePath);
            }

            if (node.getChildCount()>0)
                this.setFont(hasKidsFont);
            else
                this.setFont(hasNoKidsFont);
            
            
            if (obj instanceof PMClass) {
            }
                
            setBackground(Color.white);
            setBackground(sel ? bkselectionColor : bknonselectionColor);
            setForeground(sel ? selectionColor : nonselectionColor);

            if (node.nodeType()==ClassTreeNode.CLASS)
                setIcon(ICON_CLASS);
            else if (node.nodeType()==ClassTreeNode.METH)
                setIcon(ICON_METHOD);
            else if (node.nodeType()==ClassTreeNode.PROBE)
                setIcon(ICON_DEPLOYED_GAUGE_REQUEST);
            else
                setIcon(null);

            return this;
        }
          
        public void paintComponent(Graphics _g) {       
            Color bColor = getBackground();
            Icon icon = getIcon();
            
            _g.setColor(bColor);
            int offset = 0;
            if (icon != null && getText() != null)
                offset = (icon.getIconWidth() + this.getIconTextGap());
            _g.fillRect(offset, 0, getWidth() - 1 - offset, getHeight() - 1);
            if (m_selected) {
                _g.setColor(borderSelectionColor);
                _g.drawRect(offset, 0, getWidth()-1-offset, getHeight()-1);
            }
            
            super.paintComponent(_g);
        }
      
    }


    class ClassTreeListener implements TreeSelectionListener {
        public void valueChanged(TreeSelectionEvent e) {
            ClassTreeNode node = (ClassTreeNode)
                            classTree.getLastSelectedPathComponent();

            
            if (node == null) return;
            Object nodeInfo = node.getUserObject();
            if (nodeInfo instanceof PMClass) {
                if (!dragging) //don't evaluate if user is dragging
                    handleClassNodeSelection((PMClass)nodeInfo, node);                    
            }
            else if (nodeInfo instanceof PMMethod) {
                if (!dragging) //don't do evaluate if user is dragging
                    handleMethodNodeSelection((PMMethod)nodeInfo, node);
            }
            else if (nodeInfo instanceof PMProbe) {
//for now let the mouseadapter handle this event                
//                handleProbeNodeSelection((PMProbe)nodeInfo, node);
            }            
        }
    }

    class PopupTrigger extends MouseAdapter {
        public void mouseReleased(MouseEvent e) {   
            if (e.isPopupTrigger()) {
                int x = e.getX();
                int y = e.getY();
                TreePath path = classTree.getPathForLocation(x,y);
                clickedPath = path;
                if (path != null) {
                    ClassTreeNode node = (ClassTreeNode)
                                    path.getLastPathComponent();
                    if (node != null) {
                        Object obj = node.getUserObject();
                        if (obj instanceof PMClass) {}
                        else
                        if (obj instanceof PMMethod) {   
                            PMClass c = ((PMMethod)obj).getPMClass();
////                            try {
////                                if (c.isInnerClass())
////  	                                JOptionPane.showMessageDialog(getParent(), 
////	                                        "This method belongs to an inner class. It is not editable.", "Warning", JOptionPane.INFORMATION_MESSAGE);
////                                else                            
                                    methodPopupMenu.show(classTree, x, y);
////                            } catch (NotAvailableException nae) {
////                                classNotAvailableDialog();
////                            }
                        }
                        else
                        if (obj instanceof PMProbe) {
                            probePopupMenu.show(classTree, x, y);
                        }
                    }
                }
            } else {
                //Open probe dialog anytime a probe is clicked on
                Object target = e.getSource();
                if (target instanceof JTree) {
                    ClassTreeNode node = (ClassTreeNode) ((JTree)target).getLastSelectedPathComponent();
                    if (node==null) return;
                    Object obj = ((ClassTreeNode)node).getUserObject();
                    if (obj instanceof PMProbe) {
                        handleProbeNodeSelection((PMProbe)obj, (ClassTreeNode)node);
                    }
                }
            }
        }
    }


    //The mouse listener doesn't pick up some changes, so a list selection
    //listener is required.
	class SelectionListener implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent event)
		{
			Object object = event.getSource();
//			if (object == classesJList)
//				classesJList_listChanged(event);
//			if (object == methodsJList)
//				methodsJList_listChanged(event);
//			if (object == probesJList)
//				probesJList_listChanged(event);
		}
	}

	void handleClassNodeSelection(PMClass _cls, ClassTreeNode _node)
	{
 System.out.println("handleClassNodeSelection");	    
        manageState(1); //clear probes list
        
        try {
            loadMethodsIntoNodes(_cls, _node);
        } catch(NotAvailableException nae) {
  	        JOptionPane.showMessageDialog(this.getParent(), 
	                "The class is no longer accessible.", "Warning", JOptionPane.INFORMATION_MESSAGE);
            return;
        }
    
        //Expand or collapse node
        TreePath path = classTree.getSelectionPath();
        if (classTree.isExpanded(path)) {
            classTree.collapsePath(path);
System.out.println(".c");        
        }
        else {
            classTree.expandPath(path);                    
System.out.println(".e");        
        }
	}

	void handleMethodNodeSelection(PMMethod _meth, ClassTreeNode _node)
	{
        //manageState(1); //clear probes list
System.out.println("handleMethodNodeSelection");	    
 	         	          
        //Get name of class to see if it's an inner class
        PMClass c = _meth.getPMClass(); // getSelectedClassObject();
////        try {
////            if (c.isInnerClass()) {
////  	            JOptionPane.showMessageDialog(this.getParent(), 
////	                    "This method belongs to an inner class. It is not editable.", "Warning", JOptionPane.INFORMATION_MESSAGE);
////            }
////            else {
                //Expand or collapse node
                TreePath path = classTree.getSelectionPath();
                if (classTree.isExpanded(path))
                    classTree.collapsePath(path);                    
                else {
                    try {
                        updateProbeList(_meth, _node);                
                    } catch (CodeNotAccessibleException cna) {
                    }
                    classTree.expandPath(path);                    
                }
                
                //Get byte code for viewer
                sourceViewer.clearSource();
                if (autoLoadSource) {
//System.out.println(">>>>>>>>>>>>>>> Loading source");                    
                    JMethod pMeth = _meth.getSource();
                    if (pMeth != null)
                        sourceViewer.setSource(pMeth, _meth, _node, false); //showNums=false
                }

////            }
////        } catch (NotAvailableException nae) {
////            classNotAvailableDialog();
////        }
    } 
    

    /* Update the list of probes that are inside a method */
    void updateProbeList(PMMethod _meth, ClassTreeNode _node) 
        throws CodeNotAccessibleException {
        
        boolean addedKids = false;
        boolean hadKids = true;
        if (_node.getChildCount(false, -1) > 0)
            _node.removeAllChildren();
        else
            hadKids = false;
/*        
        java.util.Enumeration kids = _node.children();
        if (kids != null) {
            while (kids.hasMoreElements()) {
                ClassTreeNode ctn = (ClassTreeNode)kids.nextElement();
                PMProbe pm = (PMProbe)ctn.getUserObject();
System.out.println("===== updateProbeList::Removing a probe:" + pm.name());
                treeModel.removeNodeFromParent(ctn);
            }
        }
*/        
        try {
            PMProbe[] probes = _meth.getProbes();
            if (probes != null) {
                addedKids = true;
                for (int i=0; i<probes.length; i++) {
                    treeModel.insertNodeInto(ClassTreeNode.createProbeNode(probes[i]),
                        _node, treeModel.getChildCount(_node));
                }
            }
        } catch (NotAvailableException nae) { 
            classNotAvailableDialog();
        }

        if (hadKids || addedKids)
            treeModel.nodeStructureChanged(_node);

    }        

    private void classNotAvailableDialog() {
        
  	    JOptionPane.showMessageDialog(this.getParent(), 
	            "The class is not accessible.", "Warning", JOptionPane.INFORMATION_MESSAGE);                
    }


    //Clears the lists depending upon where the change occurred.
    void manageState(int level) {
        
        switch(level) {
            
            case 3: //classesJList.setListData(emptyList); //clear class list
                    //guiClassList.removeAllElements();
                    enableFiltering(false);
            case 2: //methodsJList.setListData(emptyList); //new class chosen clear methods list
            case 1: //probesJList.setListData(emptyList);  //method list changed, clear probe list
        }
    }


	class SymAction implements java.awt.event.ActionListener
	{
		public void actionPerformed(java.awt.event.ActionEvent event)
		{
			Object object = event.getSource();
            if (object == bDisconnect)
				bDisconnect_ActionPerformed(event);			
			else if (object == bResume)
				bResume_ActionPerformed(event);			
			else if (object == bRefresh)
				bRefresh_ActionPerformed(event);			
            // FILTERS
			else if (object == rbFilterNone || object == rbFilterProbe || 
			        object == rbFilterJDK || object == rbFilterIn ) 	
			{
                //user pressed another filter so disable rbGaugeDeploy
                //since user should never press it
                if (commander.isRmiOn()) rbGaugeDeploy.setEnabled(false);
                //Activate filtering
				filterClasses_ActionPerformed(event);			
            }
			else if (object == cbFilterProbes) { //re filter when user modifies this checkbox
			    if (rbFilterProbe.isSelected())
    				filterClasses_ActionPerformed(event);			
    		}
		}
    }

    /* Populates the tree with the methods of the specified class 
     * if the class hasn't already had its methods loaded.
     */
    void loadMethodsIntoNodes(PMClass _cls, ClassTreeNode _node) 
    throws NotAvailableException {
        
        
        if (_node.getChildCount() == 0) { // retrieve methods
            //index into the appropriate object array to get the class picked
            PMMethod[] meths = null;
            if (_cls != null) {
                try {
                    meths = _cls.getMethods();
                } catch (NotAvailableException nae) {
                    classNotAvailableDialog();
                    return;
                }

                boolean codeAccessible = true;
                if (meths != null) {        
                    for (int i=0; i<meths.length; i++) {
                        ClassTreeNode methNode = ClassTreeNode.createMethodNode(meths[i]);
                        treeModel.insertNodeInto(methNode,
                                _node, treeModel.getChildCount(_node));
                        //Load in its probes
                        try {
                            if (codeAccessible)
                                updateProbeList((PMMethod)methNode.getUserObject(), methNode);        
                        } catch (CodeNotAccessibleException cna) {
                            codeAccessible = false; //quite trying to examine the code 
                                                    //if we don't have access to it
                        }
                    }
                }
            }
        }
        
    }


    /* Given a PMMethod, find its class tree node */
    ClassTreeNode findNodeForMethod(PMMethod _meth) {
        
        boolean found = false;
        ClassTreeNode result = null;
        
        PMClass cls = _meth.getPMClass();
        
        //See if current list is being filtered (we need to view ALL classes)
        boolean listIsFiltered = treeModel.isFilterOn();
        if (listIsFiltered)
            treeModel.deactivateFilter(); //turn off filtering
        
        //Seach for class from location        
        int classCount = treeModel.getChildCount(treeRoot);        
        ClassTreeNode clsNode = null;
        PMClass pmc = null;
        for (int i=0; i<classCount; i++) {
            clsNode = (ClassTreeNode)treeModel.getChild(treeRoot, i);
            pmc = (PMClass) clsNode.getUserObject();
            if (pmc == cls) { //then we've found our class
                found = true;
                break; //should only be one match so break out of loop
            }
        }

        //Search methods in class
        if (found) {
            int methCount = treeModel.getChildCount(clsNode);    
            if (methCount == 0) {
                try {
                   loadMethodsIntoNodes(pmc, clsNode);
                   methCount = treeModel.getChildCount(clsNode); 
                } catch(NotAvailableException nae) {}
            }
            for (int j=0; j<methCount; j++) {
                ClassTreeNode methNode = (ClassTreeNode)treeModel.getChild(clsNode, j);
                PMMethod pm = (PMMethod) methNode.getUserObject();
                if (pm == _meth) { 
                    result = methNode;
                    break;
                }
            }
            
        }
        
        //Turn filtering back on...
        if (listIsFiltered) {
            treeModel.activateFilter(); //turn off filtering
        }
        return result;
        
    }



	ProbeInterface bAddProbe_ActionPerformed(PMMethod _meth, ClassTreeNode _node, String _pType, boolean errorsToGUI, int loc, int _aprepend)
	{
//		String ptype = cProbeTypes.getSelectedItem();
//		int pos = cProbeTypes.getSelectedIndex();
//		if (pos == 0 || ptype == null) {
//		    //no probe chosen
//    	    JOptionPane.showMessageDialog(this.getParent(), 
//	            "You must chose a probe type first.", "Information", JOptionPane.INFORMATION_MESSAGE);		    
//		    return;
//		}
		ProbeInterface probe = null;
		try {
    		probe = _meth.addProbe(_pType, loc, _aprepend);
    		
		    if (probe != null) {
                //Update Probe list if probe added
                try {
                    updateProbeList(_meth, _node);
                } catch (CodeNotAccessibleException cna) {
  	                JOptionPane.showMessageDialog(this.getParent(), 
	                        "The methods of this class are not accessible.", "Warning", JOptionPane.INFORMATION_MESSAGE);
                }

                if (_node != null) {
                    
                    if (sourceViewer.getNode() == _node) {// then update source view
                        JMethod pMeth = _meth.getSource();
                        if (pMeth != null)
                            sourceViewer.setSource(pMeth, _meth, _node, false);                        
                    }
                    //Expand node if not expanded so user can see new probe
                    TreePath path = classTree.getSelectionPath();
                    //if (!classTree.isExpanded(path))
                        classTree.expandPath(path);                    
                }
                
                return probe;
    //TEMP Commented out to expedite
    //    	    JOptionPane.showMessageDialog(this.getParent(), 
    //	            "The probe was successfully added.", "Information", JOptionPane.INFORMATION_MESSAGE);		    
		    } else {
		        if (errorsToGUI)
        	        JOptionPane.showMessageDialog(this.getParent(), 
	                "The probe could not be added.", "Information", JOptionPane.INFORMATION_MESSAGE);		    
	            return null;
		    }
        } catch (NotAvailableException nae) {
    	        JOptionPane.showMessageDialog(this.getParent(), 
	                "The probe could not be added, the class is no longer available.", "Information", JOptionPane.INFORMATION_MESSAGE);		                    
	            return null;
        } 
	}

	void bRemoveProbe_ActionPerformed(PMProbe _probe, ClassTreeNode _node)
	{
        if (_node == null) { //could this happen?
    	    JOptionPane.showMessageDialog(this.getParent(), 
	            "You must chose a probe to remove.", "Information", JOptionPane.INFORMATION_MESSAGE);		    
            return; 
        }
        try {    
    	    boolean success= _probe.getPMMethod().removeProbe(_probe);
            if (sourceViewer.getNode() == _node) {// then update source view
                JMethod pMeth = _probe.getPMMethod().getSource();
                if (pMeth != null)
                    sourceViewer.setSource(pMeth, _probe.getPMMethod(), _node, false);                        
            }
            
            if (success) {
                com.objs.surveyor.probemeister.Log.out.fine("Probe removed.");
                //Remove probe entry from configuration
                
                
                //Update Probe list if probe removed
                try {
                    updateProbeList(_probe.getPMMethod(), (ClassTreeNode)_node.getParent());
                } catch (CodeNotAccessibleException cna) {
            		com.objs.surveyor.probemeister.Log.out.fine("CodeNotAccessibleException calling updateProbeList");
                }                    
		    } else {
    	        JOptionPane.showMessageDialog(this.getParent(), 
	                "An error occurred while attempting to remove this probe.", "Information", JOptionPane.INFORMATION_MESSAGE);		    
		    }
        } catch (NotAvailableException nae) {
    	    JOptionPane.showMessageDialog(this.getParent(), 
	            "The probe could not be removed, the class is no longer available.", "Information", JOptionPane.INFORMATION_MESSAGE);		                    
        } //success stays false;			 
			 
			 
	}

    /* By default just show info dialog about probe */
	void handleProbeNodeSelection(PMProbe _probe, ClassTreeNode _node)	{
		_probe.showDescriptionDialog(this.commander); 
	}

	void bProbeInfo_ActionPerformed(PMProbe _probe, ClassTreeNode _node)
	{
        if (_node == null) { //nothing selected - can this happen?
    	    JOptionPane.showMessageDialog(this.getParent(), 
	            "You must chose a probe first.", "Information", JOptionPane.INFORMATION_MESSAGE);		    
            return; 
        }
        
		_probe.showDescriptionDialog(this.commander); 
	}




	void bDisconnect_ActionPerformed(java.awt.event.ActionEvent event) {
	    
	    String bText = this.bDisconnect.getText();
	    if (bText.equals("Disconnect")) {
	        setStatus("Disconnected"); 
	        bDisconnect.setText("Remove");
	        targetVMConnector.disconnectVM();        
	    } else if (bText.equals("Remove")) {
	        this.commander.removeVM(this);
	    }
	}

	void bResume_ActionPerformed(java.awt.event.ActionEvent event) {
	    com.objs.surveyor.probemeister.Log.out.fine("Calling resumeVM()...");
	    targetVMConnector.resumeVM();
	}

/* deprecated */
	void bRefresh_ActionPerformed(java.awt.event.ActionEvent event) {
	    //System.out.println("Calling resumeVM()...");
//	    setClassList(commander.gui2Backend().getClassList(targetVMConnector));
////////
//this.bRefresh.setEnabled(false); //alow user to update displayed list
///////
	}


    void updateClassList() {

        //First check to see if any new classes were added. If so, add them.
        int size = newClassNodes.size();
        if (size > 0) {
            //Add nodes only while all filters are deactivated
            treeModel.deactivateFilter();
            treeModel.reload();	            
            synchronized(newClassNodes) {

	            int[] indicies = new int[size];
	            int pos=0;
                for (int i=0; i<size; i++) {
                    pos = treeRoot.getChildCount();
                    treeRoot.add((ClassTreeNode)newClassNodes.elementAt(i));
                    indicies[i]=pos;
                }
                treeModel.nodesWereInserted(treeRoot, indicies);
/*                
                for (int i=0; i<size; i++)
                    treeModel.insertNodeInto((ClassTreeNode)newClassNodes.elementAt(i),
                        treeRoot, treeModel.getChildCount(treeRoot));
*/    	        
    	        newClassNodes.removeAllElements();
    	    }
	    }        
    }

    //Manages filtering of class list based upon user action - checking "filter" box
	void filterClasses_ActionPerformed(java.awt.event.ActionEvent event) {

        updateClassList();

        if (rbFilterNone.isSelected()) {
            treeModel.deactivateFilter();
            treeModel.reload();	
        }
        else
        if (rbFilterJDK.isSelected()) {
            String[] other = parseOtherFilters();
            treeModel.activateJDKFilter(other);            
            treeModel.reload();	
        }
        else
        if (rbFilterIn.isSelected()) {
            String[] filist = parseFilterInNames();
            treeModel.activateFilterInFilter(filist);            
            treeModel.reload();	
        }
        else
        if (rbFilterProbe.isSelected()) {
            //Pass the current set of probes defined so they can be filtered            
            treeModel.activateProbeFilter(commander.gui2Backend().getProbedMethods(targetVMConnector), this.cbFilterProbes.isSelected());            
            treeModel.reload();	

            //Now expand to show methods and probes- use treeModel to access nodes as
            //it knows which nodes should be visible.
            int classCount = treeModel.getChildCount(treeRoot);
	        ClassTreeNode[] path = new ClassTreeNode[3];
	        path[0] = treeRoot;
            for (int i=0; i<classCount; i++) {
                try {
                    ClassTreeNode clsNode = (ClassTreeNode)treeModel.getChild(treeRoot, i);
                    path[1] = clsNode;
                    //Now load methods, if they have not already been loaded
                    loadMethodsIntoNodes((PMClass)clsNode.getUserObject(),clsNode);
                    int methCount = treeModel.getChildCount(clsNode);
                    for (int j=0; j<methCount; j++) {
                        ClassTreeNode methNode = (ClassTreeNode)treeModel.getChild(clsNode, j);
                        //updateProbeList((PMMethod)methNode.getUserObject(), methNode);                
                        path[2] = methNode;
                        classTree.expandPath(new TreePath(path));
                    }
                } catch(NotAvailableException nae) {} //ignore & move on
            }
        }
	}
	

    /* Causes the display of the classes & methods specified in the 
     * MethodFilterList. But, also only filters on method names, so all
     * methods with the same name & different signatures will appear.
     */
    //Similar to filterClasses_ActionPerformed(where filterProbes is true).
	void filterClassesByList(MethodFilterList _list) {

        //First check to see if any new classes were added. If so, add them.
        int size = newClassNodes.size();
        if (size > 0) {
            //Add nodes only while all filters are deactivated
            treeModel.deactivateFilter();
            treeModel.reload();	            
            synchronized(newClassNodes) {

	            int[] indicies = new int[size];
	            int pos=0;
                for (int i=0; i<size; i++) {
                    pos = treeRoot.getChildCount();
                    treeRoot.add((ClassTreeNode)newClassNodes.elementAt(i));
                    indicies[i]=pos;
                }
                treeModel.nodesWereInserted(treeRoot, indicies);
    	        newClassNodes.removeAllElements();
    	    }
	    }    

        //Pass in the list 
        treeModel.activateProbeFilter(_list, true, false);            
        treeModel.reload();	

        //Now expand to show methods and probes- use treeModel to access nodes as
        //it knows which nodes should be visible.
        int classCount = treeModel.getChildCount(treeRoot);
	    ClassTreeNode[] path = new ClassTreeNode[3];
	    path[0] = treeRoot;
        for (int i=0; i<classCount; i++) {
            try {
                ClassTreeNode clsNode = (ClassTreeNode)treeModel.getChild(treeRoot, i);
                path[1] = clsNode;
                //Now load methods, if they have not already been loaded
                loadMethodsIntoNodes((PMClass)clsNode.getUserObject(),clsNode);
                int methCount = treeModel.getChildCount(clsNode);
                for (int j=0; j<methCount; j++) {
                    ClassTreeNode methNode = (ClassTreeNode)treeModel.getChild(clsNode, j);
                    //updateProbeList((PMMethod)methNode.getUserObject(), methNode);                
                    path[2] = methNode;
                    classTree.expandPath(new TreePath(path));
                }
            } catch(NotAvailableException nae) {} //ignore & move on
        }
	}



	/* Activates and deactivates filtering gui components */
    void enableFiltering(boolean _on) {
        
 		rbFilterNone.setVisible(_on);

		rbFilterJDK.setVisible(_on);
		lfilterJDKOther.setVisible(_on);
		vFilterJDKOther.setVisible(_on);
		lFilterJDKOtherNote.setVisible(_on);

		rbFilterIn.setVisible(_on);
		vFilterInNames.setVisible(_on);
		lFilterInNote.setVisible(_on);

		rbFilterProbe.setVisible(_on);
		cbFilterProbes.setVisible(_on);
                
                if (commander.isRmiOn()) {
                    rbGaugeDeploy.setVisible(_on);
                    rbGaugeDeploy.setEnabled(false);
                }
    }	
    
    /* Parses the list of filters entered by the user */
    String[] parseOtherFilters() {
     
        String f = vFilterJDKOther.getText();
        if (f == null || f.length() == 0)
            return null;
        
        Vector filters = new Vector(5);
        java.util.StringTokenizer st = new java.util.StringTokenizer(f);
        while (st.hasMoreTokens()) {
            filters.addElement(st.nextToken());
        }
        String[] fs = new String[filters.size()];
        filters.copyInto(fs);
        return fs;
    }
	

    /* Parses the list of class name strings entered by the user */
    String[] parseFilterInNames() {
     
        String f = vFilterInNames.getText();
        if (f == null || f.length() == 0)
            return null;
        
        Vector filters = new Vector(5);
        java.util.StringTokenizer st = new java.util.StringTokenizer(f);
        while (st.hasMoreTokens()) {
            filters.addElement(st.nextToken());
        }
        String[] fs = new String[filters.size()];
        filters.copyInto(fs);
        return fs;
    }
	
    /* This routine updates the associated node for a given
     * class/method. The _meth argument is expected to contain
     * the nameNSig of the method.
     */
    boolean updateProbesInMethod(String _class, String _meth) {

        String cls = _class;
        String methNSig = _meth;
        
        boolean found = false;
        boolean success = false;
        
        //See if current list is being filtered (we need to view ALL classes)
        boolean listIsFiltered = treeModel.isFilterOn();
        if (listIsFiltered)
            treeModel.deactivateFilter(); //turn off filtering
        
        //Seach for class from location        
        int classCount = treeModel.getChildCount(treeRoot);        
        ClassTreeNode clsNode = null;
        PMClass pmc = null;
        for (int i=0; i<classCount; i++) {
            clsNode = (ClassTreeNode)treeModel.getChild(treeRoot, i);
            pmc = (PMClass) clsNode.getUserObject();
            if (pmc.name().equals(cls)) { //then we've found our class
                found = true;
                break; //should only be one match so break out of loop
            }
        }

        if (found) {
            int methCount = treeModel.getChildCount(clsNode);    
            if (methCount == 0) {
                try {
                   loadMethodsIntoNodes(pmc, clsNode);
                   methCount = treeModel.getChildCount(clsNode); 
                } catch(NotAvailableException nae) {}
            }
            for (int j=0; j<methCount; j++) {
                ClassTreeNode methNode = (ClassTreeNode)treeModel.getChild(clsNode, j);
                PMMethod pm = (PMMethod) methNode.getUserObject();
                if (pm.nameNSig().equals(methNSig)) {
                    try {
                        updateProbeList(pm, methNode);
                        success = true;
                    } catch (CodeNotAccessibleException cna) {
                	    com.objs.surveyor.probemeister.Log.out.warning("Could Not update probes in method -- code not accessible.");
                    }
                    break;
                }
            }
        }
        
        //Turn filtering back on...
        if (listIsFiltered) {
            treeModel.activateFilter(); //turn off filtering
        }
        return success;
    }




class AddProbeAction extends AbstractAction {
    String pType;
    public AddProbeAction(String _s) {
        super(_s);
        pType = _s;
    }
    public void actionPerformed(ActionEvent _e) {
        if (clickedPath == null) return;
        ClassTreeNode node = 
            (ClassTreeNode)clickedPath.getLastPathComponent();                
        if (node != null) {
            if (node.getUserObject() instanceof PMMethod) {
                PMMethod meth = (PMMethod)node.getUserObject();
                bAddProbe_ActionPerformed(meth, node, pType, true, 0, 0);                
            }
        }
    }
}

    //Drag N' Drop handler for handling dropping of probes onto methods
    class ProbeDNDHandler extends javax.swing.TransferHandler {
        
        public ProbeDNDHandler(String _p) {super();}        
            
        protected Transferable createTransferable(JComponent c) {
            //System.out.println("createTransferable called with "+c.getClass().getName());
            JList jl = (JList) c;           
            Object o = jl.getSelectedValue();
            if (o instanceof GaugeRequest) {
                //selectedGaugeRequest = (GaugeRequest)o; // note which request the user selected
                return (new GaugeRequestTransferable((GaugeRequest)o));
            }
            if (o instanceof String) //probe                
                return (new java.awt.datatransfer.StringSelection((String)o));
            else { //Probes use default TransferHandler, so this should not occur.
                com.objs.surveyor.probemeister.Log.out.warning("createTransferable called with unknown type: "+o.getClass().getName());
                return null;
            }
        }
        
        public boolean importData(JComponent comp, java.awt.datatransfer.Transferable t) {
            //System.out.println("ImportData called.");
            //System.out.println("JComp = " + comp.getClass().getName());

            //First, determine what is being dropped.
            //Either a DeployRequest or a Probe

            if (t.isDataFlavorSupported(probeFlavor)||t.isDataFlavorSupported(gaugeRequestFlavor))
                return handleDrop(comp, t);
                
            java.awt.Toolkit.getDefaultToolkit().beep();                
            return false;

        }

        
        public boolean handleDrop(JComponent comp, java.awt.datatransfer.Transferable t) {

            ClassTreeNode node = null;
            PMMethod meth = null;
            int offset = 0; //default insertion pt
            int aprepend = 0; //pre- or append at offset
            
            try {
                
                //Where did drop occur?
                if (comp == sourceViewer.getList()) {
                    //Make sure that there's actually source code there!
                    //** What if the method body is empty?? Will getList be null?
                    if (sourceViewer.getList() == null || sourceViewer.getNode() == null) { 
                        java.awt.Toolkit.getDefaultToolkit().beep();
                        return false;
                    }

                    Object o = sourceViewer.getList().getSelectedValue();
                    if (!(o instanceof SourceInsertionPoint)) { //must be an Integer ('insertion pt') object
                        java.awt.Toolkit.getDefaultToolkit().beep();
                        return false;
                    }
                    offset = ((SourceInsertionPoint)o).index;
                    aprepend = ((SourceInsertionPoint)o).pend;
                    meth = sourceViewer.getMethod();
                    node = sourceViewer.getNode();
                }
                else if (comp == classTree) { //class list
                //First determine WHERE (which node the object was dropped onto)
                    node = (ClassTreeNode)
                                    ((JTree)comp).getLastSelectedPathComponent();

                    if (node == null) {
                        java.awt.Toolkit.getDefaultToolkit().beep();
                        return false;
                    }

                    Object nodeInfo = node.getUserObject();
                    if (nodeInfo instanceof PMMethod) {
                        meth = (PMMethod)nodeInfo;
                    } else {
                        java.awt.Toolkit.getDefaultToolkit().beep();
                        return false;
                    }
                }
                
                //Now, Determine WHAT was dropped
                //Handle case when it's a GaugeRequest
                if (comp == classTree && t.isDataFlavorSupported(gaugeRequestFlavor)) {
                    GaugeRequest gr = (GaugeRequest)t.getTransferData(gaugeRequestFlavor);                        
                    if (gr != null) {
                        //System.out.println("Method "+meth.name()+" Received gauge request");
                        HandleProbeDropThread pdt = new HandleProbeDropThread(gr, meth, node);
                        pdt.start();
                    }
                } else { // must be a probe that was dropped
                    String probeName = (String)t.getTransferData(probeFlavor);

//   System.out.println(">>>>>>>>>>>>Method "+meth.name()+" Received probe request using probe = "+probeName+" -- location = "+offset);
                    HandleProbeDropThread pdt = new HandleProbeDropThread(meth, node, probeName, offset, aprepend);
                    pdt.start();
                    //bAddProbe_ActionPerformed(meth, node, probeName);                
                }
                
                return true;

            } catch (java.awt.datatransfer.UnsupportedFlavorException e) {
                com.objs.surveyor.probemeister.Log.out.warning("----> Flavor not supported...");               
            } catch (java.io.IOException ioe) {
                com.objs.surveyor.probemeister.Log.out.warning("----> Flavor not supported... IOException");               
                ioe.printStackTrace();
            }
            
            return false;
        }
        
/*        
        public void exportAsDrag(JComponent comp,
                         java.awt.event.InputEvent e,
                         int action) {
        
            System.out.println("exportAsDrag called.");
            super.exportAsDrag(comp,e,action);
        }
*/        
        protected void exportDone(JComponent source,
                          Transferable data,
                          int action) {

            //We don't want classes/methods to be loaded during a drag.
            //JDK bug incorrectly calls exportDone DURING the FIRST drag,
            //so we ignore it. If exportDone called with null data, then
            //drag is not over.
            if (data != null) {
                dragging = false;
                //System.out.println("data is not null - dragging is over");
            }
//            System.out.println("exportDone called");

            super.exportDone(source, data, action);
        }
        
        
        public boolean canImport(JComponent comp,
                         java.awt.datatransfer.DataFlavor[] transferFlavors)
        { 
            //Only the classList accepts a drop... onto a method 
            if (comp == classTree || comp == sourceViewer.getList()) { 
                return true;
            }
            
            //System.out.println("Flavors:");
            //for (int i=0;i<transferFlavors.length; i++) {
            //    java.awt.datatransfer.DataFlavor df = transferFlavors[i];
            //    System.out.println("  "+df.getHumanPresentableName());
            //    System.out.println("  --->"+df.getRepresentationClass().getName());
            //}        
            return false;
        }

/*    
        public Icon getVisualRepresentation(Transferable t) {
            System.out.println("getVisualRepresentation called");
            return super.getVisualRepresentation(t);            
        }
*/    
        public int getSourceActions(JComponent c) {
            //System.out.println("getSourceActions called");
            return TransferHandler.COPY;                        
        }

    }


    class GaugeRequestTransferable implements Transferable {

        GaugeRequest gr;
        GaugeRequestTransferable(GaugeRequest _gr) {
//            System.out.println("GaugeRequestTransferable called.");
            gr = _gr;
        }

        DataFlavor[] dfs = {gaugeRequestFlavor};
        
        public DataFlavor[] getTransferDataFlavors() {
//            System.out.println("getTransferDataFlavors called.");
            return dfs;
        }
        
        public boolean isDataFlavorSupported(DataFlavor flavor) {
//            System.out.println("isDataFlavorSupported called.");
            
            if (flavor.getRepresentationClass()==GaugeRequest.class)
                return true;
            else
                return false;            
        }
        
        public Object getTransferData(DataFlavor flavor)
                            throws java.awt.datatransfer.UnsupportedFlavorException,
                                    java.io.IOException {
//            System.out.println("getTransferData called.");                                        
            return gr;                
        }
        
    }



    /* Handles probe insertion triggered by dropping a probe onto a method 
     *
     * Runs a separate thread to handle probe insertion since
     * the 'importData' method of the TransferHandler needs to return
     * before a dialog can be displayed.
     */
    class HandleProbeDropThread extends Thread {
        
        PMMethod meth;
        ClassTreeNode node;
        String pType;
        GaugeRequest gr;
        boolean probeWasDropped;
        int offset=0;
        int aprepend = 0;
        
        public HandleProbeDropThread(PMMethod _meth, ClassTreeNode _node, String _pType, int _offset, int _aprepend) {
            meth = _meth;
            node = _node;
            pType = _pType;
            probeWasDropped = true;
            offset = _offset;
            aprepend = _aprepend;
        }

        public HandleProbeDropThread(GaugeRequest _gr, PMMethod _meth, ClassTreeNode _node) {
            meth = _meth;
            node = _node;
            gr = _gr;
            probeWasDropped = false;
        }
        public void run() {
            if (probeWasDropped) 
                bAddProbe_ActionPerformed(meth, node, pType, true, offset, aprepend);                                    
            else //A GaugeRequest was dropped...
                addProbeUsingGaugeRequest(gr, meth, node);
        }
    }


   class ProbeListCellRenderer extends JLabel implements ListCellRenderer {

        // This is the only method defined by ListCellRenderer.
        // We just reconfigure the JLabel each time we're called.

        public Component getListCellRendererComponent(
        JList list,
        Object value,            // value to display
        int index,               // cell index
        boolean isSelected,      // is the cell selected
        boolean cellHasFocus)    // the list and the cell have the focus
        {
            //GaugeRequest gr = value.toString();
            String s = value.toString();
            setText(s);
            boolean isStub = commander.gui2Backend().isProbeAStub(s);
            setIcon(isStub ? ICON_PROBE_STUB : ICON_PROBE);
   	        if (isSelected) {  	        
                setBackground(list.getSelectionBackground());
	            setForeground(list.getSelectionForeground());
	        }
            else {
	            setBackground(list.getBackground());
  	            setForeground(list.getForeground());
	        }
	        setEnabled(list.isEnabled());
	        setFont(list.getFont());
            setOpaque(true);
            
            return this;
        }
    }



////////////////////////////////////////////////////////////
// RMI specific code
////////////////////////////////////////////////////////////

    public String processGaugeDeployRequest(GaugeRequest _gr) {
        String errStr="";
        boolean success = true;
        //First see if this request should be deployed automatically
        int dOpt=-1;
        try {
            dOpt = _gr.getDeployOption();
        } catch (java.rmi.RemoteException re) {
            return "Could Not Access Remote Object.";   
        }
        
        if (dOpt == GaugeRequestInterface.REUSE_LAST_CONFIG) {
            //Get location from past gauge request entry
            GaugeRequestLocation loc = this.lookupLastGaugeRequestLocation(_gr);
            if (loc != null) {
                PMMethod pmMeth = getPMMethodForLocation(loc);
                if (pmMeth != null) {
                    //Try & deploy probe
                    ClassTreeNode methNode = findNodeForMethod(pmMeth);
                    ProbeInterface probe = 
                        addProbeUsingGaugeRequest(_gr, pmMeth, methNode);
                    if (probe != null)
                        success = true;
                } else { 
                    errStr = "Method location could not be found.";
                    success = false;
                }
            } else { 
                errStr = "No deployment history found.";
                success = false;
            }
        }

        //Add to list
        DefaultListModel dlm = (DefaultListModel)this.gaugeDeployList.getModel();
        dlm.addElement(_gr);
        setGaugeListButtons(true); //make sure their enabled
        if (success)
            return null; // all ok
        else
            return errStr;
    }

    public void delGaugeDeployRequest() {

        int pos = this.gaugeDeployList.getSelectedIndex();
        if (pos <0) {
	        JOptionPane.showMessageDialog(commander, 
	                "Select a Gauge Request to remove.", "Information", JOptionPane.INFORMATION_MESSAGE);
            return;
        }
        
        DefaultListModel dlm = (DefaultListModel)this.gaugeDeployList.getModel();
        dlm.removeElementAt(pos);
        
        if (dlm.getSize() ==0) // deactivate buttons
            setGaugeListButtons(false);
    }
    
    void setGaugeListButtons(boolean _on) {        
        this.bActivateGaugeRequest.setEnabled(_on);
        this.bRemoveGaugeRequest.setEnabled(_on);
    }

	class GaugeActionListener implements java.awt.event.ActionListener
	{
		public void actionPerformed(java.awt.event.ActionEvent event)
		{
			Object object = event.getSource();
            if (object == bActivateGaugeRequest) {
                GaugeRequest gr = (GaugeRequest)gaugeDeployList.getSelectedValue();
                if (gr != null)
    				activateGaugeRequest(gr);		
    		    else 
 	                JOptionPane.showMessageDialog(commander, 
	                    "Select a Gauge Request to Activate.", "Information", JOptionPane.INFORMATION_MESSAGE);   		        
			}
			else if (object == bRemoveGaugeRequest)
				delGaugeDeployRequest();		
    	}
    }
    
    void activateGaugeRequest(GaugeRequest _gr) {
     
        //Prepare filter list
        MethodFilterList fList = new MethodFilterList();
        try {
            GaugeRequestLocationInterface[] locs = _gr.getLocations();
            for (int i=0; i<locs.length; i++)
                fList.addMethod(locs[i].getClassName(), locs[i].getMethodName());
            
            //Send list to filter classes
            this.filterClassesByList(fList);
            
            //Highlight Gauge filter button indicating filtering method
            rbGaugeDeploy.setEnabled(true);       
            rbGaugeDeploy.setSelected(true);
        } catch (java.rmi.RemoteException re) {
    		javax.swing.JOptionPane.showMessageDialog(commander, "Remote Error occurred displaying request.", 
    		"Error", javax.swing.JOptionPane.INFORMATION_MESSAGE);            
        }            
    }
    
    /* This routine handles a deployment associated
     * with a GaugeDeploymentRequest. When this occurs, an 
     * association between the request and the actual deployed 
     * location needs to be recorded for later reference.
     *
     * Also writes out the configuration for this deployment
     * to the GaugeRequestHistoryManager.
     */
    ProbeInterface addProbeUsingGaugeRequest(GaugeRequest _gr, PMMethod _meth, ClassTreeNode _node) {
        
        com.objs.surveyor.probemeister.Log.out.info("addProbeUsingGaugeRequest called...");        
        ProbeInterface probe = null;
        try {
            if (_gr.getDeployed()) {
    		    javax.swing.JOptionPane.showMessageDialog(commander, "This Gauge Request has already been deployed.", 
    		    "Error", javax.swing.JOptionPane.INFORMATION_MESSAGE);            
                return null;
            }
            
            //if GaugeRequest.params is null, then user must configure
            //if GaugeRequest.plugClass is null...
            int loc = 0;
            
            loc = _gr.getLocationForMethod(_meth.getPMClass().name(), _meth.name());    
            if (loc == -2) { //yuck! No location found signal
                Object[] options = { "At End", "At start"};                
                int retVal = javax.swing.JOptionPane.showOptionDialog(commander, 
                    "This location is not one of the recommended locations, where should it be deployed?", 
                    "Gauge Request",
                    javax.swing.JOptionPane.DEFAULT_OPTION, javax.swing.JOptionPane.INFORMATION_MESSAGE,
                    null, options, options[1]);				

                loc = retVal - 1; // loc=-1:at end; loc=0:at start                        
            }
                
            if (_gr.getProbeParams() == null) {
                com.objs.surveyor.probemeister.Log.out.fine("Adding gauge using PREPEND_AT_LOCATION");        
                probe = bAddProbe_ActionPerformed(_meth, _node, _gr.getProbeName(), false, loc, 0);
                if (probe != null)
                    _gr.setDeployed(true);
            }
            else {
                com.objs.surveyor.probemeister.Log.out.fine("Adding gauge using PREPEND_AT_LOCATION");        
                probe = addProbeWithParamInfo(_gr, _meth, _node, loc, 0);
            }
            
            
            //Add deployment to history
            if (probe != null) { //mark request 'deployed'
                //get the actual deployed location
                String sLoc = "0";
                try {
                    sLoc = ""+probe.getProbeLocation().getOffset();
                } catch (Exception e) {
                    sLoc = "error";
                }
                GaugeRequestHistoryManager.mgr().add(_gr, _meth, loc);            
                //Use our ref to GaugeRequest assigned when object was 
                //exported to drag n drop
                //if (selectedGaugeRequest!=null)
                //    selectedGaugeRequest.setDeployed(true);
                GaugeRequest g = (GaugeRequest)gaugeDeployList.getSelectedValue();
                _gr.setDeployed(true);
                if (g != null) // Hmmmmm? Is this nec?
                    g.setDeployed(true);
                    
                gaugeDeployList.repaint(); //to update gauge look
            }
        } catch (java.rmi.RemoteException re) {}        
        return probe;
    }
 
    /* Adds a probe when the gauge request supplies probe/plug info using a Map */
    ProbeInterface addProbeWithParamInfo(GaugeRequest _gr, PMMethod _meth, ClassTreeNode _node, int _loc, int _aprepend) {

 		ProbeInterface probe = null;
 		
 		try {
            com.objs.surveyor.probemeister.probe.ProbePlugEntry plug = 
                com.objs.surveyor.probemeister.probe.ProbePlugCatalog.getCataloger().findPlugByName(_gr.getPlugClass(), _gr.getPlugName());
            if (plug == null) { // not found!! Return error
                com.objs.surveyor.probemeister.Log.out.info("addProbeWithParamInfo:: requested plug not found =>"+_gr.getPlugClass()+":"+_gr.getPlugName());        
    		    javax.swing.JOptionPane.showMessageDialog(commander, "Could not find plug for gauge request. Probe not deployed.", 
    		    "Error", javax.swing.JOptionPane.INFORMATION_MESSAGE);            
                return null;
            } 
    		probe = _meth.addProbe(_gr.getProbeName(), _gr.getDeployID(), _gr.getDeployDesc(), _gr.getProbeParams(), plug, _loc, _aprepend);
    		
		    if (probe != null) {
                //Update Probe list if probe added
                try {
                    updateProbeList(_meth, _node);
                } catch (CodeNotAccessibleException cna) {
  	                JOptionPane.showMessageDialog(this.getParent(), 
	                        "The methods of this class are not accessible.", "Warning", JOptionPane.INFORMATION_MESSAGE);
                }

                if (_node != null) {
                    //Expand node if not expanded so user can see new probe
                    TreePath path = classTree.getSelectionPath();
                    //if (!classTree.isExpanded(path))
                        classTree.expandPath(path);                    
                }
                
                return probe;
		    } else {
        	    JOptionPane.showMessageDialog(this.getParent(), 
	            "A gauge requested probe could not be added.", "Information", JOptionPane.INFORMATION_MESSAGE);		    
	            return null;
		    }
        } catch (NotAvailableException nae) {
    	        JOptionPane.showMessageDialog(this.getParent(), 
	                "The gauge requested probe could not be added, the class is no longer available.", "Information", JOptionPane.INFORMATION_MESSAGE);		                    
	            return null;
        } catch (java.rmi.RemoteException re) {
    	        JOptionPane.showMessageDialog(this.getParent(), 
	                "The gauge requested probe could not be added, a RemoteException occurred.", "Information", JOptionPane.INFORMATION_MESSAGE);		                    
	            return null;
        } 
    }
 
 
    GaugeRequestLocation lookupLastGaugeRequestLocation(GaugeRequest _gr) {
        
        GaugeRequestLocation[] locs = lookupPastGaugeRequestLocations(_gr);
        if (locs != null && locs.length >0)
            return locs[locs.length-1]; //return the last entry
        else
            return null;    
    }
    
    GaugeRequestLocation[] lookupPastGaugeRequestLocations(GaugeRequest _gr) {
        
        return GaugeRequestHistoryManager.mgr().lookup(_gr);        
    }
    

    /* This routine finds the associated PMMethod for a given
     * gauge request. The GaugeRequestLocation is expected to contain
     * the nameNSig of the method, as it is coming from the
     * GaugeRequestHistoryManager...
     */
    PMMethod getPMMethodForLocation(GaugeRequestLocation _loc) {
       
        updateClassList();
       
        String cls = null;
        String methNSig = null;
        try {
            cls = _loc.getClassName();
            methNSig = _loc.getMethodName();
        } catch (java.rmi.RemoteException re) {
            return null;   
        }
        
        PMMethod pmm = null; //attr holding found method
        boolean found = false;
        
        //See if current list is being filtered (we need to view ALL classes)
        boolean listIsFiltered = treeModel.isFilterOn();
        if (listIsFiltered)
            treeModel.deactivateFilter(); //turn off filtering
        
        //Seach for class from location        
        int classCount = treeModel.getChildCount(treeRoot);        
        ClassTreeNode clsNode = null;
        PMClass pmc = null;
        for (int i=0; i<classCount; i++) {
            clsNode = (ClassTreeNode)treeModel.getChild(treeRoot, i);
            pmc = (PMClass) clsNode.getUserObject();
            if (pmc.name().equals(cls)) { //then we've found our class
                found = true;
                break; //should only be one match so break out of loop
            }
        }

        if (found) {
            int methCount = treeModel.getChildCount(clsNode);        
            if (methCount == 0) {
                try {
                   loadMethodsIntoNodes(pmc, clsNode);
                   methCount = treeModel.getChildCount(clsNode); 
                } catch(NotAvailableException nae) {}
            }
            
            for (int j=0; j<methCount; j++) {
                ClassTreeNode methNode = (ClassTreeNode)treeModel.getChild(clsNode, j);
                PMMethod pm = (PMMethod) methNode.getUserObject();
                if (pm.nameNSig().equals(methNSig)) {
                    pmm=pm;
                    break;
                }
            }
        }
        
        //Turn filtering back on...
        if (listIsFiltered) 
            treeModel.activateFilter(); //turn off filtering
            

        return pmm;

    }

    
    /* This routine finds the associated PMMethods for a given
     * gauge request. The GaugeRequestLocation is expected to contain
     * the name (NO SIG) of the method, as it is coming via RMI
     */
    Vector getPMMethodsForLocation(GaugeRequestLocation _loc) {
       
        updateClassList();
       
        String cls = null;
        String methName = null;
        try {
            cls = _loc.getClassName();
            methName = _loc.getMethodName();
        } catch (java.rmi.RemoteException re) {
            return null;   
        }
        
        Vector meths = new Vector(); //attr holding found method
        boolean found = false;
        
        //See if current list is being filtered (we need to view ALL classes)
        boolean listIsFiltered = treeModel.isFilterOn();
        if (listIsFiltered)
            treeModel.deactivateFilter(); //turn off filtering
        
        //Seach for class from location        
        int classCount = treeModel.getChildCount(treeRoot);        
        ClassTreeNode clsNode = null;
        PMClass pmc = null;
        for (int i=0; i<classCount; i++) {
            clsNode = (ClassTreeNode)treeModel.getChild(treeRoot, i);
            pmc = (PMClass) clsNode.getUserObject();
            if (pmc.name().equals(cls)) { //then we've found our class
                found = true;
                break; //should only be one match so break out of loop
            }
        }

        if (found) {
            int methCount = treeModel.getChildCount(clsNode);        
            if (methCount == 0) {
                try {
                   loadMethodsIntoNodes(pmc, clsNode);
                   methCount = treeModel.getChildCount(clsNode); 
                } catch(NotAvailableException nae) {}
            }

            for (int j=0; j<methCount; j++) {
                ClassTreeNode methNode = (ClassTreeNode)treeModel.getChild(clsNode, j);
                PMMethod pm = (PMMethod) methNode.getUserObject();
                if (pm.name().equals(methName)) {
                    meths.addElement(pm); //add matching method
                }
            }
        } 
        
        
        //Turn filtering back on...
        if (listIsFiltered) 
            treeModel.activateFilter(); //turn off filtering
            

        return meths;

    }
    
    
    class GaugeRequestListCellRenderer extends JLabel implements ListCellRenderer {

        // This is the only method defined by ListCellRenderer.
        // We just reconfigure the JLabel each time we're called.

        public Component getListCellRendererComponent(
        JList list,
        Object value,            // value to display
        int index,               // cell index
        boolean isSelected,      // is the cell selected
        boolean cellHasFocus)    // the list and the cell have the focus
        {
            GaugeRequest gr = (GaugeRequest)value;
            String s = value.toString();
            setText(s);
            boolean deployed = false;
            try {
                deployed = gr.getDeployed();
            } catch (java.rmi.RemoteException re) {
                setText(s+"--Cannot access remote object");
            }
            setIcon(deployed ? ICON_DEPLOYED_GAUGE_REQUEST : ICON_UNDEPLOYED_GAUGE_REQUEST);
            if (deployed) {
    	        setForeground(Color.GRAY);
    	    }
    	    else
    	        setForeground(Color.red); //list.getForeground());
   	        if (isSelected) {  	        
                setBackground(list.getSelectionBackground());
	            //setForeground(list.getSelectionForeground());
	        }
            else {
	            setBackground(list.getBackground());
	        }
	        setEnabled(list.isEnabled());
	        setFont(list.getFont());
            setOpaque(true);
            
            return this;
        }
    }
 
//    deployGaugeRequestFromDialog(grd.getSelectedRecommended(), grd.getSelectedPast());
    void deployGaugeRequestFromDialog(GaugeRequest _gr, GaugeRequestLocation[] _reco, GaugeRequestLocation[] _past) {
        
        boolean success = false;
        Vector allLocs   = new Vector();
        //Vector finalLocs = new Vector();
        
        //Add selected recommended locations
        if (_reco != null && _reco.length > 0) { //Add ALL duplicate methods by name
                                                 // as we have no sigs in this request.
            for (int x=0; x< _reco.length; x++) {
                Vector locs = getPMMethodsForLocation(_reco[x]);
                //create a GaugeRequest for each entry (all methods with same name are included)
                java.util.Iterator methIter = locs.iterator();
                while (methIter.hasNext()) { 
                    PMMethod pm = (PMMethod)methIter.next();
                    try {
                        GaugeRequestLocation newLoc = new GaugeRequestLocation(_reco[x]);
                        newLoc.setMethodName(pm.nameNSig());
                        allLocs.addElement(newLoc);            
                    } catch (Exception e) {
                        com.objs.surveyor.probemeister.Log.out.warning(
                            "Error Processing Gauge Request:: perhaps the remote object is not accessible.");                    
                    }
                }                
            }
        }
        
        //Add selected past locations
        if (_past != null && _past.length > 0) { //add these to the allLocs Vector
            for (int x=0; x< _past.length; x++) {
                allLocs.addElement(_past[x]);
            }
        }

JOptionPane.showMessageDialog(this.getParent(), 
"Deploying "+allLocs.size()+" probes", "Information", JOptionPane.INFORMATION_MESSAGE);		    
        
        int count = 0;
        //Now deploy each GaugeRequest
        int index=0;
        if (allLocs.size() > 0) {
            java.util.Iterator iter = allLocs.iterator();
            while (iter.hasNext()) {
                index++;
                GaugeRequestLocation grl = (GaugeRequestLocation)iter.next();
                PMMethod pm = getPMMethodForLocation(grl);
                if (pm != null) {
                    ClassTreeNode ctn = findNodeForMethod(pm);
                    if (ctn != null) {
                        //ADD PROBE
                        if (addProbeUsingGaugeRequest(_gr, pm, ctn) != null)
                            count++;
                    }
                    else
                        com.objs.surveyor.probemeister.Log.out.warning(
                            "Error Deploying at Gauge Location "+index+":: cannot find node for method: "+ pm.getPMClass().name()+":"+pm.name());                    
                } else {
                    try {
                        com.objs.surveyor.probemeister.Log.out.warning(
                            "Error Deploying at Gauge Location "+index+":: cannot find Probe Method for gauge location: "+grl.getClassName()+":"+grl.getMethodName());
                    } catch (Exception e) {
                        com.objs.surveyor.probemeister.Log.out.warning(
                            "Deploying Gauge:: cannot find Probe Method for gauge location:: perhaps the remote object is not accessible.");                    
                    }

                }                    
            }
            if (count >0)
                success = true; //some level of success
        } else {
        	    JOptionPane.showMessageDialog(this.getParent(), 
	            "No locations selected, the gauge request was not deployed.", "Information", JOptionPane.INFORMATION_MESSAGE);		    
	            success = false;            
        }
        
        
        if (success) {
        	JOptionPane.showMessageDialog(this.getParent(), 
	        ""+count+" out of "+allLocs.size()+" probes deployed.", "Information", JOptionPane.INFORMATION_MESSAGE);		    
            try { //update status of gauge request        
                _gr.setDeployed(true);
            } catch (java.rmi.RemoteException re) {
            }
        } else
            if (allLocs.size()!= 0)
        	    JOptionPane.showMessageDialog(this.getParent(), 
	            "Errors occurred, no probes were deployed for this Gauge Request.", "Information", JOptionPane.INFORMATION_MESSAGE);		    
        
    }
}