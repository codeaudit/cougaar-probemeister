/*
 * <copyright>
 *
 *  Copyright 1999-2004 Object Services and Consulting, Inc.
 *  under sponsorship of the Defense Advanced Research Projects
 *  Agency (DARPA).
 *
 *  You can redistribute this software and/or modify it under the
 *  terms of the Cougaar Open Source License as published on the
 *  Cougaar Open Source Website (www.cougaar.org).
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * </copyright>
 */
/*
 * SourceViewer.java
 *
 * Created on August 15, 2002, 1:01 PM
 */
package com.objs.surveyor.probemeister.gui;
import jreversepro.reflect.JMethod;
import jreversepro.reflect.*;

import java.util.Iterator;
import java.util.List;
import javax.swing.DefaultListModel;
import javax.swing.JLabel;
import javax.swing.JList;
import java.awt.Font;
import java.awt.Color;
import java.awt.Component;
import javax.swing.ListCellRenderer;

/**
 *
 * @author  Administrator
 */
public class SourceViewer extends javax.swing.JFrame {
    
    boolean userCancelled;
    DefaultListModel dlm;
    TargetVMDataPanel tvmdp;
    
    /** Creates new form SourceViewer */
    public SourceViewer(TargetVMDataPanel _tvmdp) {
        tvmdp = _tvmdp; //for callbacks
        initComponents();
        if (_tvmdp == null) setSize(600,400);
        dlm = new javax.swing.DefaultListModel();
        sourceList.setModel(dlm);
        sourceList.setCellRenderer(new CodeRenderer());
        //initDND();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    private void initComponents() {//GEN-BEGIN:initComponents
        headerPanel = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        sourcePanel = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        sourceList = new javax.swing.JList();
        controlPanel = new javax.swing.JPanel();
        bOK = new javax.swing.JButton();
        bCancel = new javax.swing.JButton();

        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                exitForm(evt);
            }
        });

        headerPanel.setMinimumSize(new java.awt.Dimension(10, 30));
        headerPanel.setPreferredSize(new java.awt.Dimension(10, 30));
        jLabel1.setText("Source Viewer");
        headerPanel.add(jLabel1);

        getContentPane().add(headerPanel, java.awt.BorderLayout.NORTH);

        sourcePanel.setLayout(new java.awt.GridLayout(1, 0));

        sourcePanel.setBorder(new javax.swing.border.EmptyBorder(new java.awt.Insets(15, 15, 15, 15)));
        sourceList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        jScrollPane1.setViewportView(sourceList);

        sourcePanel.add(jScrollPane1);

        getContentPane().add(sourcePanel, java.awt.BorderLayout.CENTER);

        controlPanel.setPreferredSize(new java.awt.Dimension(10, 70));
        bOK.setText("OK");
        bOK.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bOKActionPerformed(evt);
            }
        });

        controlPanel.add(bOK);

        bCancel.setText("Cancel");
        bCancel.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bCancelActionPerformed(evt);
            }
        });

        controlPanel.add(bCancel);

        getContentPane().add(controlPanel, java.awt.BorderLayout.SOUTH);

        pack();
    }//GEN-END:initComponents

    private void bCancelActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bCancelActionPerformed
        // Add your handling code here:
        userCancelled = true;
        this.hide();
    }//GEN-LAST:event_bCancelActionPerformed

    private void bOKActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bOKActionPerformed
        // Add your handling code here:
        userCancelled = false;
        this.hide();
    }//GEN-LAST:event_bOKActionPerformed
    
    /** Exit the Application */
    private void exitForm(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_exitForm
        userCancelled = true;
        this.hide();
    }//GEN-LAST:event_exitForm
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        new SourceViewer(null).show();
    }
    
    public javax.swing.JList getList() { 
        return sourceList;
    }    
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton bOK;
    private javax.swing.JButton bCancel;
    private javax.swing.JPanel headerPanel;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JPanel sourcePanel;
    private javax.swing.JPanel controlPanel;
    private javax.swing.JList sourceList;
    private javax.swing.JLabel jLabel1;
    // End of variables declaration//GEN-END:variables
    
    
    public void setSource(JMethod jpm, boolean showNums) {
        //sjf List l = jpm.getLinesOfCode(); 
        List l = jpm.getBlock().getFlattenedCode("");
        
        //jpm.processCode("**OBJS-START**","**OBJS-END**","pmID="); //assume one method for now...
        
        String space="          ";
        int len = 0;
        JLineOfCode loc = null;
        
        for (int j=0; j<l.size(); j++) {
            
            loc = (JLineOfCode)l.get(j);
            addInsertionEntry(l, j, loc);
            
            //sjf String p = loc.p ? "PROBE ---> " : ""; 
            String p = ""; 

            if (showNums) {
                String num="";
                if (loc.getStart()>=0) {
                    num = ""+loc.getStart()+"-"+loc.getEnd()+":";
                    len = num.length();
                    p=num+p;                
                } else 
                    len = 0;            
                p=space.substring(len,space.length())+p;
            }
            loc.setViz(p+loc.getStmt());
            dlm.addElement(loc);
            
            //ps.print(jpms[i].toString(false, true));
            //ps.println("----------------------");
        }   
        if (l.size()>0) // add last entry
            addInsertionEntry(l, -1, loc);
    }        
    
    void addInsertionEntry(List l, int pos, JLineOfCode loc) {
        
        //first check the current LOC
        if (loc.getStart() >= 0) // then a probe can go before it, insert Insertion bar
            dlm.addElement(getSpacer()); //blank
        else if (pos >0) { // check the LOC before this
            JLineOfCode loct = (JLineOfCode)l.get(pos-1);
            if (loct.getStart()>=0)
                dlm.addElement(getSpacer()); //blank
        }
                
    }
    
    Object getSpacer() {
        return new Object();
//        JLabel j = new JLabel(".");
//        j.setSize(10,20);
//        return j;
    }
    
    class CodeRenderer extends JLabel
                           implements ListCellRenderer {

        Font CODEFONT = new Font("SanSerif", Font.PLAIN, 12);                               
        Font NULLFONT = new Font("SanSerif", Font.PLAIN, 3);                               

        public CodeRenderer() {
            setOpaque(true);
            //setHorizontalAlignment(CENTER);
            //setVerticalAlignment(CENTER);
        }
        public Component getListCellRendererComponent(
            JList list,
            Object value,
            int index,
            boolean isSelected,
            boolean cellHasFocus)
        {
            if (isSelected) {
                setBackground(list.getSelectionBackground());
                setForeground(list.getSelectionForeground());
            } else {
                setBackground(list.getBackground());
                setForeground(list.getForeground());
            }

            if (value instanceof JLineOfCode) { 
                JLineOfCode loc = (JLineOfCode)value;
                setText(loc.toString());
                setFont(CODEFONT);
                //if (isSelected) {
                //    setBackground(list.getSelectionBackground());
                //    setForeground(list.getSelectionForeground());
                //} else {
                //Don't highlight lines, only space between lines
                setBackground(list.getBackground());
                setForeground(list.getForeground());
                //}
            } else { //blank line
                setText(" ");
                setFont(NULLFONT);                
                if (isSelected) {
                    setBackground(Color.black);
                    setForeground(Color.black);
                } else {
                    //setBackground(Color.red);
                    //setForeground(Color.red);
                    setBackground(list.getBackground());
                    setForeground(list.getForeground());
                }
            }
            //setIcon(icon);
            return this;
        }
    }   
/*
    void initDND() {
    		gaugeDeployList.setDragEnabled(true);
    		gaugeDeployList.setTransferHandler(new ProbeDNDHandler(null));
    		
		    gaugeDeployListPane.setOpaque(true);
		    add(gaugeDeployListPane);
		    gaugeDeployListPane.setBounds(240,297,250,90);
          
            java.awt.event.MouseListener ml3 = new MouseAdapter() {
                public void mouseClicked(MouseEvent e){
                    //dragging = false; //used by tree listener so it doesn't load method / probes
                                // when a probe/gauge is dragged across them
                    //System.out.println("dragging = false -- mouse clicked");

                    if(e.getClickCount() == 2){
                    int index = gaugeDeployList.locationToIndex(e.getPoint());
                    if (index<0) return;
                        ListModel dlm = gaugeDeployList.getModel();
                        
                        GaugeRequest gr = (GaugeRequest)dlm.getElementAt(index);
                        gaugeDeployList.ensureIndexIsVisible(index);
                        if (gr != null) {
                            GaugeRequestDialog grd = new GaugeRequestDialog(commander, gr);
                            //Get Past Locations
                            GaugeRequestLocation[] pastLocs = lookupPastGaugeRequestLocations(gr);
                            if (pastLocs != null)
                                grd.setPastLocationsList(pastLocs);
                            //set display
                            grd.show();       
                            if (grd.getDeployGauge())
                                deployGaugeRequestFromDialog(gr, grd.getSelectedRecommended(), grd.getSelectedPast());
                        }
                    }
                }
            };
            
            // When dragging occurs, it exports the GaugeRequest to be dropped
            // onto a method.
            //  
            java.awt.event.MouseMotionListener ml4 = new java.awt.event.MouseMotionAdapter() {
                public void mouseDragged(MouseEvent e) { 
                    JList c = (JList)e.getSource();
                    TransferHandler th = c.getTransferHandler();
                    dragging = true;
                   
                    //System.out.println("dragging = true");
                    th.exportAsDrag(c, e, TransferHandler.COPY);
                }
            };
    }

    //********************************************************************
    //Drag N' Drop handler for handling dropping of probes onto methods
    class ProbeDNDHandler extends javax.swing.TransferHandler {
        
        public ProbeDNDHandler(String _p) {super();}        
            
        protected Transferable createTransferable(JComponent c) {
            //System.out.println("createTransferable called with "+c.getClass().getName());
            JList jl = (JList) c;           
            Object o = jl.getSelectedValue();
            if (o instanceof GaugeRequest) {
                //selectedGaugeRequest = (GaugeRequest)o; // note which request the user selected
                return (new GaugeRequestTransferable((GaugeRequest)o));
            }
            if (o instanceof String) //probe                
                return (new java.awt.datatransfer.StringSelection((String)o));
            else { //Probes use default TransferHandler, so this should not occur.
                com.objs.surveyor.probemeister.Log.out.warning("createTransferable called with unknown type: "+o.getClass().getName());
                return null;
            }
        }
        
        public boolean importData(JComponent comp, java.awt.datatransfer.Transferable t) {
            //System.out.println("ImportData called.");
            //System.out.println("JComp = " + comp.getClass().getName());

            //First, determine what is being dropped.
            //Either a DeployRequest or a Probe

            if (t.isDataFlavorSupported(probeFlavor)||t.isDataFlavorSupported(gaugeRequestFlavor))
                return handleDrop(comp, t);
                
            java.awt.Toolkit.getDefaultToolkit().beep();                
            return false;

        }

        
        public boolean handleDrop(JComponent comp, java.awt.datatransfer.Transferable t) {
            try {
                
                //First determine WHERE (which node the object was dropped onto)
                ClassTreeNode node = (ClassTreeNode)
                                ((JTree)comp).getLastSelectedPathComponent();
                    
                if (node == null) {
                    java.awt.Toolkit.getDefaultToolkit().beep();
                    return false;
                }
                
                Object nodeInfo = node.getUserObject();
                if (nodeInfo instanceof PMClass) {
                    java.awt.Toolkit.getDefaultToolkit().beep();
                }
                else if (nodeInfo instanceof PMMethod) {
                    PMMethod meth = (PMMethod)nodeInfo;

                    //Now, Determine WHAT was dropped
                    //Handle case when it's a GaugeRequest
                    if (t.isDataFlavorSupported(gaugeRequestFlavor)) {
                        GaugeRequest gr = (GaugeRequest)t.getTransferData(gaugeRequestFlavor);                        
                        if (gr != null) {
                            //System.out.println("Method "+meth.name()+" Received gauge request");
                            HandleProbeDropThread pdt = new HandleProbeDropThread(gr, meth, node);
                            pdt.start();
                        }
                    } else { // must be a probe that was dropped
                        String probeName = (String)t.getTransferData(probeFlavor);
                        
                        //System.out.println("Method "+meth.name()+" Received probe request using probe = "+probeName);
                        HandleProbeDropThread pdt = new HandleProbeDropThread(meth, node, probeName);
                        pdt.start();
                        //bAddProbe_ActionPerformed(meth, node, probeName);                
                    }
                }
                else if (nodeInfo instanceof PMProbe) {
                    java.awt.Toolkit.getDefaultToolkit().beep();
                }            
                
                return true;

            } catch (java.awt.datatransfer.UnsupportedFlavorException e) {
                com.objs.surveyor.probemeister.Log.out.warning("----> Flavor not supported...");               
            } catch (java.io.IOException ioe) {
                com.objs.surveyor.probemeister.Log.out.warning("----> Flavor not supported... IOException");               
                ioe.printStackTrace();
            }
            
            return false;
        }
 */      
/* **************       
        public void exportAsDrag(JComponent comp,
                         java.awt.event.InputEvent e,
                         int action) {
        
            System.out.println("exportAsDrag called.");
            super.exportAsDrag(comp,e,action);
        }
*********************/        
/*    
        protected void exportDone(JComponent source,
                          Transferable data,
                          int action) {

            //We don't want classes/methods to be loaded during a drag.
            //JDK bug incorrectly calls exportDone DURING the FIRST drag,
            //so we ignore it. If exportDone called with null data, then
            //drag is not over.
            if (data != null) {
                dragging = false;
                //System.out.println("data is not null - dragging is over");
            }
//            System.out.println("exportDone called");

            super.exportDone(source, data, action);
        }
        
        
        public boolean canImport(JComponent comp,
                         java.awt.datatransfer.DataFlavor[] transferFlavors)
        { 
            //Only the classList accepts a drop... onto a method 
            if (comp == classTree) { 
                return true;
///                TreePath p = ((JTree)comp).getSelectionPath();
//                if (p!= null) {                    
//                    ClassTreeNode node = (ClassTreeNode)p.getLastPathComponent();                    
//                    Object nodeInfo = node.getUserObject();
//                    if (nodeInfo instanceof PMMethod)                
//                        return true;                
//                }
//                
            }
            
            //System.out.println("Flavors:");
            //for (int i=0;i<transferFlavors.length; i++) {
            //    java.awt.datatransfer.DataFlavor df = transferFlavors[i];
            //    System.out.println("  "+df.getHumanPresentableName());
            //    System.out.println("  --->"+df.getRepresentationClass().getName());
            //}        
            return false;
        }

//    
//        public Icon getVisualRepresentation(Transferable t) {
//            System.out.println("getVisualRepresentation called");
//            return super.getVisualRepresentation(t);            
//        }
//    
        public int getSourceActions(JComponent c) {
            //System.out.println("getSourceActions called");
            return TransferHandler.COPY;                        
        }

    }


    class GaugeRequestTransferable implements Transferable {

        GaugeRequest gr;
        GaugeRequestTransferable(GaugeRequest _gr) {
//            System.out.println("GaugeRequestTransferable called.");
            gr = _gr;
        }

        DataFlavor[] dfs = {gaugeRequestFlavor};
        
        public DataFlavor[] getTransferDataFlavors() {
//            System.out.println("getTransferDataFlavors called.");
            return dfs;
        }
        
        public boolean isDataFlavorSupported(DataFlavor flavor) {
//            System.out.println("isDataFlavorSupported called.");
            
            if (flavor.getRepresentationClass()==GaugeRequest.class)
                return true;
            else
                return false;            
        }
        
        public Object getTransferData(DataFlavor flavor)
                            throws java.awt.datatransfer.UnsupportedFlavorException,
                                    java.io.IOException {
//            System.out.println("getTransferData called.");                                        
            return gr;                
        }
        
    }



    // Handles probe insertion triggered by dropping a probe onto a method 
     //
     // Runs a separate thread to handle probe insertion since
     // the 'importData' method of the TransferHandler needs to return
     // before a dialog can be displayed.
     //
    class HandleProbeDropThread extends Thread {
        
        PMMethod meth;
        ClassTreeNode node;
        String pType;
        GaugeRequest gr;
        boolean probeWasDropped;

        public HandleProbeDropThread(PMMethod _meth, ClassTreeNode _node, String _pType) {
            meth = _meth;
            node = _node;
            pType = _pType;
            probeWasDropped = true;
        }

        public HandleProbeDropThread(GaugeRequest _gr, PMMethod _meth, ClassTreeNode _node) {
            meth = _meth;
            node = _node;
            gr = _gr;
            probeWasDropped = false;
        }
        public void run() {
            if (probeWasDropped)
                bAddProbe_ActionPerformed(meth, node, pType, true, 0);                    
            else //A GaugeRequest was dropped...
                addProbeUsingGaugeRequest(gr, meth, node);
        }
    }
*/    
}
